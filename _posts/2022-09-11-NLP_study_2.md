---
title:  "NLP 공부하기 2"
excerpt: "02. 텍스트 전처리(Text Preprocessing)"

categories:
  - language
tags:
  - [language, NLP]

toc: true
toc_sticky: true
toc_label : "C O N T E N T S"
 
date: 2022-09-11
last_modified_at: 2022-09-11
---  

이 내용들은 전부 딥 러닝을 이용한 자연어 처리 입문 (Won Joon Yoo) [링크](https://wikidocs.net/book/2155)에서 참고했습니다.

## 02 텍스트 전처리(Text preprocessing)

텍스트 전처리는 풀고자 하는 문제의 용도에 맞게 텍스트를 사전에 처리하는 작업입니다. 텍스트에 제대로 전처리를 하지 않으면 뒤에서 배울 자연어 처리 기법들이 제대로 동작하지 않습니다. 이번 챕터에서는 텍스트를 위한 다양한 전처리 방법들에 대해서 다룹니다.


### 1) 토큰화(Tokenization)

자연어 처리에서 크롤링 등으로 얻어낸 코퍼스 데이터가 필요에 맞게 전처리되지 않은 상태라면, 해당 데이터를 사용하고자하는 용도에 맞게 토큰화, 정제, 정규화 하는 일을 하게 됩니다. 이번에는 그 중에서도 토큰화에 대해서 학습합니다.

주어진 코퍼스(corpus)에서 토큰(token)이라 불리는 단위로 나누는 작업을 토큰화(tokenization)라고 합니다. 토큰의 단위가 상황에 따라 다르지만, 보통 의미있는 단위로 토큰을 정의합니다. 여기서는 토큰화에 대한 발생할 수 있는 여러가지 상황에 대해서 언급하여 토큰화에 대한 개념을 이해합니다. 이어서 NLTK, KoNLPY를 통해 실습을 진행하며 토큰화를 수행합니다.

#### 1. 단어 토큰화(Word Tokenization)

토큰의 기준을 단어(word)로 하는 경우, 단어 토큰화(word tokenization)라고 합니다. 다만, 여기서 단어(word)는 단어 단위 외에도 단어구, 의미를 갖는 문자열로도 간주되기도 합니다.

예를 들어보겠습니다. 아래의 입력으로부터 구두점(punctuation)과 같은 문자는 제외시키는 간단한 단어 토큰화 작업을 해봅시다. 구두점이란 마침표(.), 쉼표(,), 물음표(?), 세미콜론(;), 느낌표(!) 등과 같은 기호를 말합니다.

입력: `Time is an illusion. Lunchtime double so!`

이러한 입력으로부터 구두점을 제외시킨 토큰화 작업의 결과는 다음과 같습니다.

출력 : "Time", "is", "an", "illustion", "Lunchtime", "double", "so"

구두점을 지운 뒤에 띄어쓰기(whitespace)를 기준으로 잘라냈습니다. 하지만 이 예제는 토큰화의 가장 기초적인 예제를 보여준 것에 불과합니다.

보통 토큰화 작업은 단순히 구두점이나 특수문자를 전부 제거하는 정제(cleaning) 작업을 수행하는 것만으로 해결되지 않습니다. 구두점이나 특수문자를 전부 제거하면 토큰이 의미를 잃어버리는 경우가 발생하기도 합니다. 심지어 띄어쓰기 단위로 자르면 사실상 단어 토큰이 구분되는 영어와 달리, 한국어는 띄어쓰기만으로는 단어 토큰을 구분하기 어렵습니다.

#### 2. 토큰화 중 생기는 선택의 순간

토큰화를 하다보면, 예상하지 못한 경우가 있어서 토큰화의 기준을 생각해봐야 하는 경우가 발생합니다. 물론, 이러한 선택은 해당 데이터를 가지고 어떤 용도로 사용할 것인지에 따라서 그 용도에 영향이 없는 기준으로 정하면 됩니다. 예를 들어 영어권 언어에서 아포스트로피를(')가 들어가있는 단어는 어떻게 토큰으로 분류해야 하는지에 대한 선택의 문제를 보여드리겠습니다.

다음과 같은 문장이 있다고 해봅시다.

`Don't be fooled by the dark sounding name, Mr. Jone's Orphanage is as cheery as cheery goes for a pastry shop.`

아포스트로피가 들어간 상황에서 Don't와 Jone's는 어떻게 토큰화할 수 있을까요? 다양한 선택지가 있습니다.

Don't
Don t
Dont
Do n't
Jone's
Jone s
Jone
Jones

이 중 사용자가 원하는 결과가 나오도록 토큰화 도구를 직접 설계할 수도 있겠지만, 기존에 공개된 도구들을 사용하였을 때의 결과가 사용자의 목적과 일치한다면 해당 도구를 사용할 수도 있을 것입니다. NLTK는 영어 코퍼스를 토큰화하기 위한 도구들을 제공합니다. 그 중 word_tokenize와 WordPunctTokenizer를 사용해서 아포스트로피를 어떻게 처리하는지 확인해보겠습니다.


```python
import keras
keras.__version__
tf.keras.__version__
```




    '2.9.0'



#### 3. 젠심(Gensim)

<u>젠심은 머신 러닝을 사용하여 토픽 모델링과 자연어 처리 등을 수행할 수 있게 해주는 오픈 소스 라이브러리입니다.</u> 여기서도 젠심을 사용하여 Word2Vec 등 다양한 모델들을 학습해볼 것입니다.
```python
pip install gensim
```


```python
import gensim
gensim.__version__
```




    '4.1.2'



#### 4. 사이킷런(Scikit-learn)

사이킷런은 파이썬 머신러닝 라이브러리입니다. <u>사이킷런을 통해 나이브 베이즈 분류, 서포트 벡터 머신 등 다양한 머신 러닝 모듈을 불러올 수 있습니다.</u> 또한, 사이킷런에는 머신러닝을 연습하기 위한 아이리스 데이터, 당뇨병 데이터 등 자체 데이터 또한 제공하고 있습니다.  
자세한 자체 데이터 내용은 [여기](https://rudolf-2434.tistory.com/2)에서 확인할 수 있습니다.  
```python
pip install scikit-learn
```



```python
import sklearn
sklearn.__version__
```




    '1.1.1'



#### 5. 주피터 노트북(Jupyter Notebook)

주피터 노트북은 웹에서 코드를 작성하고 실행할 수 있는 오픈소스 웹 어플리케이션입니다. 
```python
pip install jupyter
```  
설치가 완료되었다면 프롬프트에 다음 명령어를 통해 주피터 노트북을 실행할 수 있습니다.
```python
jupyter notebook
```

### 3) 자연어 처리를 위한 NLTK와 KoNLPy 설치하기

텍스트 전처리(Text preprocessing) 챕터에서는 전처리를 위한 이론에 대해서 학습하고, 그 이론을 바탕으로 실습을 진행합니다. 그리하여 실습에 필요한 기본적인 자연어 패키지들을 소개합니다.

#### 1. NLTK와 NLTK Data 설치

<u>NLTK는 자연어 처리를 위한 파이썬 패키지입니다.</u> 아나콘다를 설치하였다면 NLTK는 기본적으로 설치가 되어져 있습니다. 만약 아나콘다를 설치하지 않았다면 아래의 커맨드로 NLTK를 별도 설치할 수 있습니다.
```python
pip install nltk
```


```python
import nltk
nltk.__version__
```




    '3.7'



NLTK의 기능을 제대로 사용하기 위해서는 NLTK Data라는 여러 데이터를 추가적으로 설치해야 합니다. 이를 위해서는 아나콘다 프롬프트에서 ipython을 이용하여 아래의 코드를 실행합니다.
```python
import nltk
nltk.download('데이터 이름')
```


```python
nltk.download('treebank') # 아나콘다 콘솔창에서 ipython으로 다운받기
```

    [nltk_data] Downloading package treebank to
    [nltk_data]     C:\Users\komos\AppData\Roaming\nltk_data...
    [nltk_data]   Package treebank is already up-to-date!
    




    True



#### 2. KoNLPy 설치

<u>KoNLPy는 한국어 자연어 처리를 위한 형태소 분석기 패키지입니다.</u> 프롬프트에서 아래 커맨드로 설치합니다.  
```python
pip install konlpy
```



```python
import konlpy
konlpy.__version__
```




    '0.6.0'



### 4) 판다스(Pandas)와 넘파이(Numpy), 맷플롭립(Matplotlib)

#### 1. Pandas

Pandas는 파이썬 데이터 처리를 위한 라이브러리입니다. 파이썬을 이용한 데이터 분석과 같은 작업에서 필수 라이브러리입니다. 


```python
import pandas as pd
pd.__version__
```




    '1.4.3'



Pandas의 경우 pd라는 명칭으로 임포트하는 것이 관례입니다.  

Pandas는 총 세 가지의 데이터 구조를 사용합니다.

* 시리즈(Series)
* 데이터프레임(DataFrame)
* 패널(Panel)

이 중 데이터프레임이 가장 많이 사용됩니다.

##### (1) 시리즈(Series)

시리즈 클래스는 1차원 배열의 값에 각 값에 대응하는 인덱스를 부여할 수 있는 구조를 갖고 있습니다.


```python
sr = pd.Series([17000, 18000, 1000, 5000], index = ['피자', '치킨', '콜라', '맥주'])
print('시리즈 출력 : ')
print('-' * 15)
print(sr)
```

    시리즈 출력 : 
    ---------------
    피자    17000
    치킨    18000
    콜라     1000
    맥주     5000
    dtype: int64
    


```python
print(f'시리즈의 값 : {sr.values}')
print(f'시리즈의 인덱스 : {sr.index}')
```

    시리즈의 값 : [17000 18000  1000  5000]
    시리즈의 인덱스 : Index(['피자', '치킨', '콜라', '맥주'], dtype='object')
    

##### (2) 데이터프레임(DataFrame)

데이터프레임은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스와 열방향 인덱스가 존재합니다. 다시 말해 행과 열을 가지는 자료구조입니다. 시리즈가 인덱스와 값으로 구성된다면, 데이터프레임은 열까지 추가되어 열, 인덱스, 값으로 구성됩니다. 


```python
value = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
index = ['one', 'two', 'three']
columns = ['A', 'B', 'C']

df = pd.DataFrame(value, index = index, columns = columns)
print('데이터프레임 출력')
print('-' * 15)
print(df)
```

    데이터프레임 출력
    ---------------
           A  B  C
    one    1  2  3
    two    4  5  6
    three  7  8  9
    


```python
print(f'데이터프레임 인덱스 : {df.index}')
print(f'데이터프레임 열이름 : {df.columns}')
print('데이터프레임 값')
print('-' * 15)
print(df.values)
```

    데이터프레임 인덱스 : Index(['one', 'two', 'three'], dtype='object')
    데이터프레임 열이름 : Index(['A', 'B', 'C'], dtype='object')
    데이터프레임 값
    ---------------
    [[1 2 3]
     [4 5 6]
     [7 8 9]]
    

##### (3) 데이터프레임의 생성

데이터프레임은 리스트, 시리즈, 딕셔너리, Numpy의 ndarrays, 또 다른 데이터프레임으로부터 생성할 수 있습니다. 여기서는 리스트와 딕셔너리를 사용하여 데이터프레임을 생성해보겠습니다.


```python
# 리스트를 이용하여 DataFrame 생성하기
data = [
    ['1000', 'Steve', 90.72],
    ['1001', 'James', 78.09],
    ['1002', 'Doyeon', 98.43],
    ['1003', 'Jang', 64.19],
    ['1004', 'Pilwoong', 81.30],
    ['1005', 'Tony', 99.14]
]

df = pd.DataFrame(data)
print(df)
```

          0         1      2
    0  1000     Steve  90.72
    1  1001     James  78.09
    2  1002    Doyeon  98.43
    3  1003      Jang  64.19
    4  1004  Pilwoong  81.30
    5  1005      Tony  99.14
    

생성된 데이터프레임에 열을 지정해줄 수 있습니다. 


```python
df = pd.DataFrame(data, columns = ['학번', '이름', '점수'])
print(df)
```

         학번        이름     점수
    0  1000     Steve  90.72
    1  1001     James  78.09
    2  1002    Doyeon  98.43
    3  1003      Jang  64.19
    4  1004  Pilwoong  81.30
    5  1005      Tony  99.14
    


```python
# 딕셔너리를 이용하여 DataFrame 생성하기
data = {
    '학번' : ['1000', '1001', '1002', '1003', '1004', '1005'],
    '이름' : ['Steve', 'James', 'Doyeon', 'Jang', 'Pilwoong', 'Tony'],
    '점수' : [90.72, 78.09, 98.43, 64.19, 81.30, 99.14]
}

df = pd.DataFrame(data)
print(df)
```

         학번        이름     점수
    0  1000     Steve  90.72
    1  1001     James  78.09
    2  1002    Doyeon  98.43
    3  1003      Jang  64.19
    4  1004  Pilwoong  81.30
    5  1005      Tony  99.14
    

##### (4) 데이터프레임 조회하기

아래의 명령어들은 데이터프레임에서 원하는 구간만 확인하기 위한 명령어로서 유용하게 사용됩니다.

* df.head(n) : 앞 부분을 n개만 보기
* df.tail(n) : 뒷 부분을 n개만 보기
* df['열이름'] : 해당되는 열을 확인


```python
print(df.head(3))
```

         학번      이름     점수
    0  1000   Steve  90.72
    1  1001   James  78.09
    2  1002  Doyeon  98.43
    


```python
print(df.tail(3))
```

         학번        이름     점수
    3  1003      Jang  64.19
    4  1004  Pilwoong  81.30
    5  1005      Tony  99.14
    


```python
print(df['학번'])
```

    0    1000
    1    1001
    2    1002
    3    1003
    4    1004
    5    1005
    Name: 학번, dtype: object
    

##### (5) 외부 데이터 읽기

Pandas는 CSV, Text, Excel, SQL, HTML, JSON 등 다양한 데이터 파일을 읽고 데이터프레임을 생성할 수 있습니다.

```python
df = pd.read_csv('파일경로 + 파일.확장자')
print(df)
```

#### 2. 넘파이(Numpy)

넘파이는 수치 데이터를 다루는 파이썬 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.


```python
import numpy as np
np.__version__
```




    '1.21.5'



Numpy의 경우 np라는 명칭으로 임포트하는 것이 관례입니다. 

##### (1) np.array()

Numpy의 핵심은 ndarray입니다. np.array()는 리스트, 튜플, 배열로 부터 ndarray를 생성합니다. 


```python
# 1차원 배열
ls = [1, 2, 3, 4, 5]
vec = np.array(ls)
print(vec)
```

    [1 2 3 4 5]
    

2차원 배열은 array() 안에 하나의 리스트만 들어가므로 리스트의 리스트를 넣어야 한다는 주의사항이 있습니다.


```python
# 2차원 배열 
ls = [[10, 20, 30], [40, 50, 60]] 
mat = np.array(ls)
print(vec)
```

    [1 2 3 4 5]
    


```python
print(f'vec의 타입 : {type(vec)}')
print(f'mat의 타입 : {type(mat)}')
```

    vec의 타입 : <class 'numpy.ndarray'>
    mat의 타입 : <class 'numpy.ndarray'>
    

Numpy 배열에는 축의 개수(ndim)와 크기(shape)라는 개념이 존재하는데, 배열의 크기를 정확히 숙지하는 것은 딥 러닝에서 매우 중요합니다. 


```python
print(f'vec의 축의 개수 : {vec.ndim}')
print(f'vec의 크기(shape) : {vec.shape}')
```

    vec의 축의 개수 : 1
    vec의 크기(shape) : (5,)
    


```python
print(f'mat의 축의 개수 : {mat.ndim}')
print(f'mat의 크기(shape) : {mat.shape}')
```

    mat의 축의 개수 : 2
    mat의 크기(shape) : (2, 3)
    

##### (2) ndarray의 초기화

ndarray를 만드는 다양한 다른방법이 존재합니다. 

np.zeros()는 배열의 모든 원소에 0을 삽입합니다.


```python
# 모든 값이 0인 2x3 배열 생성
zeros_mat = np.zeros((2, 3))
print(zeros_mat)
```

    [[0. 0. 0.]
     [0. 0. 0.]]
    

np.ones()는 배열의 모든 원소에 1을 삽입합니다.


```python
# 모든 값이 1인 2x3 배열 생성
ones_mat = np.ones((2, 3))
print(ones_mat)
```

    [[1. 1. 1.]
     [1. 1. 1.]]
    

np.full()은 배열에 사용자가 지정한 값을 삽입합니다.


```python
# 모든 값이 특정 상수인 배열 생성
same_value_mat = np.full((2, 3), 7)
print(same_value_mat)
```

    [[7 7 7]
     [7 7 7]]
    

np.eye()는 단위행렬을 생성합니다.


```python
# 단위행렬 배열 생성
eye_mat = np.eye(3)
print(eye_mat)
```

    [[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]
    

np.random.random()은 임임의 값을 가지는 배열을 생성합니다.


```python
# 임의의 값으로 채워진 배열 생성
random_mat = np.random.random((2, 3))
print(random_mat)
```

    [[0.96345682 0.66609107 0.81700229]
     [0.52387823 0.66283696 0.18852439]]
    

##### (3) np.arange()

np.arange(n)은 0부터 n-1까지의 값을 가지는 배열을 생성합니다.


```python
range_vec = np.arange(10)
print(range_vec)

print('\n')

n = 2
range_vec = np.arange(1, 10, n)
print(range_vec)
```

    [0 1 2 3 4 5 6 7 8 9]
    
    
    [1 3 5 7 9]
    

##### (4) np.reshape()

np.reshape()은 내부 데이터는 변경하지 않으면서 배열의 구조를 바꿉니다.


```python
reshape_mat = np.array(np.arange(30)).reshape(5, 6)
print(reshape_mat)
```

    [[ 0  1  2  3  4  5]
     [ 6  7  8  9 10 11]
     [12 13 14 15 16 17]
     [18 19 20 21 22 23]
     [24 25 26 27 28 29]]
    

##### (5) Numpy 슬라이싱

ndarray를 통해 만든 다차원 배열은 파이썬의 자료구조인 리스트처럼 슬라이싱 기능을 지원합니다. 슬라이싱 기능을 사용하여 특정 행이나 열들으 원소들을 접근할 수 있습니다.


```python
mat = np.array([[1, 2, 3], [4, 5, 6]])
print(mat)
```

    [[1 2 3]
     [4 5 6]]
    


```python
# 첫번째 행 출력
print(mat[0 ,:])
```

    [1 2 3]
    


```python
# 두번째 열 출력
print(mat[:, 1])
```

    [2 5]
    

##### (6) Numpy 정수 인덱싱

슬라이싱을 사용하면 배열로부터 부분 배열을 추출할 수 있지만, 연속적이지 않은 원소로 배열을 만들 경우에는 슬라이싱으로는 만들 수 없습니다. 이런 경우에는 인덱싱을 사용하여 배열을 구성할 수 있습니다. 인덱싱은 원하는 위치의 원소들을 뽑을 수 있습니다.


```python
mat = np.array([[1, 2], [4, 5], [7, 8]])
print(mat)

print(mat[[2, 1], [1, 1]])

indexing_mat = mat[[2, 1], [1, 1]]
print(indexing_mat)
```

    [[1 2]
     [4 5]
     [7 8]]
    [8 5]
    [8 5]
    

##### (7) Numpy 연산

Numpy를 사용하면 배열간 연산을 손쉽게 수행할 수 있습니다. +, -, *, /를 사용할 수 있으며 또는 np.add(), np.subtract(), np.multiply(), np.divide()를 사용할 수도 있습니다.


```python
x = np.array([1, 2, 3])
y = np.array([4, 5, 6])
```


```python
result = x + y
print(result)

result = x - y
print(result)

result = x * y
print(result)

result = x / y
print(result)
```

    [5 7 9]
    [-3 -3 -3]
    [ 4 10 18]
    [0.25 0.4  0.5 ]
    

위에서 *를 통해 수행한 것은 요소별 곱입니다. Numpy에서 벡터와 행렬의 곱 또는 행렬곱을 위해서는 dot()을 사용해야 합니다.


```python
mat1 = np.array([[1, 2], [3, 4]])
mat2 = np.array([[5, 6], [7, 8]])
mat3 = np.dot(mat1, mat2)
print(mat3)
```

    [[19 22]
     [43 50]]
    

#### 3. 맷플롯립(Matplotlib)

Matplotlib은 데이터를 차트나 plot으로 시각화하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이ㅐㅎ를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.

##### (1) 라인 플롯 그리기

plot()은 라인 plot을 그리는 기능을 수행합니다. plot()에 x축과 y축의 값을 기재하고 그림을 표시하는 show()를 통해서 시각화합니다. 추가적으로 title('제목')을 사용하여 그래프의 제목을 지정할 수 있으며, xlabel('X 라벨'), ylabel('Y 라벨')을 이용해 축의 이름을 지정할 수 있습니다. 또한 legend('범례1', '범례2')를 이용하여 다수의 plot의 범례를 지정할 수 있습니다.


```python
import matplotlib.pyplot as plt

plt.plot([1, 2, 3, 4], [2, 4, 8, 6])
plt.plot([1.5, 2.5, 3.5, 4.5], [3, 5, 8, 10])
plt.title('test')
plt.xlabel('hour')
plt.ylabel('score')
plt.legend(['A student', 'B student'])
plt.show
```




    <function matplotlib.pyplot.show(close=None, block=None)>




    
![png](output_67_1.png)
    


### 5) 판다스 프로파이링(Pandas-Profiling)

좋은 머신 러닝 결과를 얻기 위해서는 데이터의 성격을 파악하는 과정이 선행되어야 합니다. 이 과정에서 데이터 내 값의 분포, 변수 간의 관계, Null 값과 같은 결측값 존재 유무 등을 파악하게 되는데 이와 같이 데이터를 파악하는 과정을 EDA(Exploratory Data Analysis)이라고 합니다. 이번에는 방대한 양의 데이터를 가진 데이터프레임을 .profiling_report()라는 단 한 줄의 명령으로 탐색하는 패키지인 판다스 프로파일링을 소개합니다.

아나콘다 프롬프트에서 아래의 pip 명령을 통해 패키지를 설치합니다.  
```python
conda install -c conda-forge pandas-profiling
```

#### 1. 실습 파일 불러오기

실습을 위해 아래 링크에서 spam.csv란 파일을 다운로드 했습니다.  
[링크](https://www.kaggle.com/uciml/sms-spam-collection-dataset)  

spam.csv를 다운로드 받았다면 해당 파일을 불러왔습니다.


```python
import pandas as pd
import pandas_profiling

data = pd.read_csv('C:/Users/komos/pytorch/NLP/spam.csv', encoding='latin1')
```

여기서 encoding은 파일을 불러올 때 데이터가 잘 불러오기 위해 encoding을 지정하는 것입니다. csv 를 읽을 때 encoding을 utf-8로 하면 에러가 발생합니다. 그래서 encoding을 latin1으로 설정해야 합니다. 하지만 만약 불러오기 전이나 후에 엑셀 또는 csv 파일을 열었을 경우 다시 불러오면 데이터 내의 한글파일이 깨져있을 수 있습니다. 이는 파일을 열었을 때 encoding이 cp949로 변경되기 때문입니다. 그래서 이러한 깨짐현상이 나타났을 경우 encoding을 cp949로 변경해야합니다.  
자세한 내용은 [링크](https://kamang-it.tistory.com/245)에서 확인가능합니다.


```python
data[:5]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>v1</th>
      <th>v2</th>
      <th>Unnamed: 2</th>
      <th>Unnamed: 3</th>
      <th>Unnamed: 4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ham</td>
      <td>Go until jurong point, crazy.. Available only ...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ham</td>
      <td>Ok lar... Joking wif u oni...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>spam</td>
      <td>Free entry in 2 a wkly comp to win FA Cup fina...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ham</td>
      <td>U dun say so early hor... U c already then say...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ham</td>
      <td>Nah I don't think he goes to usf, he lives aro...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



이 데이터에는 총 5개의 열이 있는데, 여기서 Unnamed라는 이름의 3개의 열은 5개의 행만 출력했음에도 벌써 Null값이 보입니다. v1열은 해당 메일이 스팸인지 아닌지를 나타내는 레이블에 해당되는 열입니다. ham은 정상 메일을 의미하고, spam은 스팸메일을 의미합니다. v2열은 메일의 본문을 담고 있습니다.

실행을 하다보면 에러가 발생할 수도 있습니다. 
```python
ImportError: cannot import name 'soft_unicode' from 'markupsafe' ...
```
이는 pandas profiling을 실행하기 위해서는 markupsafe에서 `soft_unicode`가 필요한데 markupsafe의 최신 버전에서는 soft_unicode가 빠져서 발생하는 에러입니다.  
그리하여 이전 버전(2.0.1)의 markupsafe를 다운받으면 됩니다.
```python
pip install markupsafe==2.0.1
```


```python
pr = pandas_profiling.ProfileReport(data) # data.profile_report() 도 가능
pr.to_file('./pr_report.html')
```


    Summarize dataset:   0%|          | 0/5 [00:00<?, ?it/s]



    Generate report structure:   0%|          | 0/1 [00:00<?, ?it/s]



    Render HTML:   0%|          | 0/1 [00:00<?, ?it/s]



    Export report to file:   0%|          | 0/1 [00:00<?, ?it/s]


데이터프레임에 .profile_report()(pandas_profiling.ProfileReport(data)로도 가능)를 사용하여 데이터를 프로파일링한 리포트를 생성할 수 있습니다.   

주피터 노트북으로 리포트를 확인할 수도 있겠지만, 위의 .to_file() 명령을 통해 HTML파일로 저장하는 것도 가능합니다.

#### 2. 리포트 살펴보기

##### (1) 개요(Overview)

Overview는 데이터의 전체적인 개요를 보여줍니다. 변수의 수, 데이터의 크기, 결측값 비율, 데이터의 종류는 어떤 것이 있는지를 볼 수 있습니다.

Dataset statistics를 살펴보면 해당 데이터는 총 5572개의 행을 가지고 있으며, 5개의 열을 가지고 있습니다. 하나의 값을 셀이라고 하였을 때, 총 5572 x 5 개의 데이터가 존재하지만 16648개(59.8%)의 결측값이 있는 것으로 확인됩니다.

##### (2) 변수(Variables)

변수는 데이터에 존재하는 모든 특성 변수들에 대한 결측값, 중복을 제외한 유일한 값(unique values)의 개수 등의 통계치를 보여줍니다. 또한 데이터의 내용을 우측 바 그래프로 시각화한 결과를 제공합니다.

우선 Unnamed라는 이름을 가진 3개의 열에 대해 알아보겠습니다. 앞서 개요에서 봤듯이 3개의 열 모두 99% 이상의 값이 결측값입니다. 결측값이 아닌 값들은 5572 - 5522 = 50개이며 그 중 중복을 제거한 유일한 값의 개수는 44개입니다. (Distint에서 확인 가능)

그 다음은 다른 2개의 열인 v1과 v2를 보겠습니다. v2는 메일의 본문이고, v1은 해당 메일이 정상 메일인지, 스팸 메일인지 유부가 기재되어져 있습니다. v1의 경우 유일한 값의 개수가 2개뿐으로 우측 바 그래프를 통해 4825개가 ham, 747가 spam인 것을 알 수 있습니다. 이는 데이터에서 정상 메일 샘플이 훨씬 많다는 것을 보여줍니다. v2의 경우 5572개의 메일 본문 중에서 중복을 제외하면 5169개의 유일한 내용의 메일 본문을 갖고 있습니다. 그 중 중복이 가장 많은 메일은 Sorry, I'll call later 이라는 내용의 메일로 총 30개의 메일이 존재합니다.

또한 v1과 v2 모두 결측값은 존재하지 않는데, 이는 결과적으로 데이터 전처리를 수행할 때, Unnamed라는 3개의 열을 제거하고 나서는 별도의 결측값 전처리는 필요가 없음을 의미합니다.

이번에는 각 변수에 있는 상세사항 확인하기(Toggle details)를 알아보겠습니다.

##### (3) 상세사항 확인하기(Toggle details)

상세사항 확인하기에서는 총 4개의 탭이 존재하는데, 첫번째 탭인 Overview에서는 변수 내용의 문자열 개수, 전체 문자열 개수, 중복 되지 않는 문자열 개수, 유일한 단어 개수 등을 알려줍니다. 이 후 Categories, Word 에서는 데이터의 빈도를 바 그래프로 나타내주고, Characters 에서는 문자열의 빈도를 나타내줍니다.




### 6) 머신 러닝 워크플로우(Machine Learning Workflow)

이번에는 데이터 사이언스 또는 머신 러닝과정에서 거치는 전반적인 과정에 대해서 알아보겠습니다. 딥 러닝 또한 머신러닝의 한 갤래로 딥 러닝 워크플로우 또한 머신 러닝 워크플로우로 간주 할 수 있습니다.

#### 1. 머신 러닝 워크플로우(Machine Learning Workflow)

데이터를 수집하고 머신 러닝을 하는 과정을 크게 6가지로 나누면, 아래의 그림과 같습니다. ![머신_러닝_워크플로우](https://user-images.githubusercontent.com/60602671/187525048-5245e6aa-b0f0-4702-84ab-675e5f0502d8.png)

##### (1) 수집(Acquisition)

머신 러닝을 하기 위해서는 기계에 학습시켜야 할 데이터가 필요합니다. 자연어처리의 경우, 자연어 데이터를 `말뭉치 또는 코퍼스(corpus)`라고 부르는데 코퍼스의 의미를 풀이하면, 조사나 연구 목적에 의해서 특정 도메인으로부터 수집된 텍스트 집합을 말합니다. 텍스트 데이터의 파일 형식은 txt파일, csv파일, xml파일 등 다야앟며 그 출처도 음성 데이터, 웹 수집기를 통해 수집된 데이터, 영화 리뷰 등 다양합니다.

##### (2) 점검 및 탐색(Inspection and exploration)

데이터가 수집되었다면, 이제 데이터를 점검하고 탐색하는 단계입니다. 여기서는 데이터의 구조, 노이즈 데이터, 머신 러닝 적용을 위해서 데이터를 어떻게 정제해야하는지 등을 파악합니다.

이 단계를 `탐색적 데이터 분석(Exploratory Data Analysis, EDA) 단계`라고도 하는데 이는 독립 변수, 종속 변수, 변수 유형, 변수의 데이터 타입 등을 점검하며 데이터의 특징과 내재하는 구조적 관계를 알아내는 과정을 의미합니다. 이 과정에서 시각화와 간단한 통계 테스트를 진행하기도 합니다.

##### (3) 전처리 및 정제(Preprocessing and Cleaning)

데이터에 대한 파악이 끝났다면, 머신 러닝 워크플로우에서 가장 까다로운 작업 중 하나인 데이터 전처리 과정에 들어갑니다. 이 단계는 많은 단계를 포함하고 있는데, 가령 자연어 처리라면 토큰화, 전제, 정규화, 불용어 제거 등의 단계를 포함합니다. 빠르고 정확한 데이터 전처리를 하기 위해서는 사용하고 있는 툴(python)에 대한 다양한 라이브러리에 대한 지식이 필요합니다. 정말 까다로운 전처리의 경우에는 전처리 과정에서 머신 러닝이 사용되기도 합니다. 

##### (4) 모델링 및 훈련(Modeling and Training)

데이터 전처리가 끝났다면, 머신 러닝에 대한 코드를 작성하는 단계인 모델링 단계에 들어갑니다. 적절한 머신 러닝 알고리즘을 선택하여 모델링이 끝났다면, 전처리가 완료 된 데이터를 머신 러닝 알고리즘을 통해 기계에서 학습시킵니다. 기계가 데이터에 대한 학습을 마치고나서 훈련이 제대로 되었다면 그 후에 기계는 우리가 원하는 태스크인 기계 번역, 음석 인식, 텍스트 분류 등의 처리 작업을 수행할 수 있게 됩니다.

여기서 주의해야 할 점은 대부분의 경우에서 모든 데이터를 기계에서 학습시켜서는 안된다는 점입니다. 데이터 중 일부는 테스트용으로 남겨두고 훈련용 데이터만 훈련에 사용해야 합니다. 그래야만 기계가 학습을 하고나서, 테스트용 데이터를 통해서 현재 성능이 얼마나 되는지를 측정할 수 있으며, 과적합(overfitting) 상황을 막을 수 있습니다. 사실 최선은 훈련용, 테스트용 두 가지만 나누는 것보다는 훈련용, 검증용, 테스트용으로 데이터를 이렇게 세가지로 나누고, 훈련용 데이터만 훈련에 사용하는 것입니다.

![데이터](https://user-images.githubusercontent.com/60602671/187543147-bc9100c6-dc28-43b6-af47-7746f0bf687e.png)

검증용 데이터는 현재 모델의 성능. 즉, 기계가 훈련용 데이터로 얼마나 제대로 학습이 되었는지를 판단하는 용으로 사용되며 검증용 데이터를 사용하여 모델의 성능을 개선하는데 사용됩니다. 테스트용 데이터는 모델의 최종 성능을 평가하는 데이터로 모델의 성능을 개선하는 일에 사용되는 것이 아니라, 모델의 성능을 수치화하여 평가하기 위해 사용됩니다.

실습 상황에 따라서 훈련용, 검증용, 테스트용 세 가지를 모두 사용하거나 때로는 훈련용, 테스트용 두 가지만 사용하기도 합니다. 하지만 현업에서 최선은 검증용 데이터 또한 사용하는 것임을 기억해둡시다.

##### (5) 평가(Evaluation)

기계가 다 학습이 되었다면 테스트용 데이터로 성능을 평가하게 됩니다. 평가 방법은 기계가 예측한 데이터가 테스트용의 실제 정답과 얼마나 가까운지를 측정합니다.

##### (6) 배포(Deployment)

평가 단계에서 기계가 성공적으로 훈련이 된 것으로 판단된다면 완성된 모델이 배포되는 단계가 됩니다. 다만, 여기서 완성된 모델에 대한 전체적인 피드백으로 인해 모델을 업데이트해야 하는 상황이 온다면 수집 단계로 돌아갈 수 있습니다.

## 02. 텍스트 전처리(Text Preprocessing)

텍스트 전처리는 풀고자 하는 문데의 용도에 맞게 텍스트를 사전에 처리하는 작업입니다. 텍스트에 제대로 전처리를 하지 않으면 뒤에서 배울 자연어 처리 기법들이 제대로 동작하지 않습니다. 이번 챕터에서는 텍스트를 위한 다양한 전처리 방법들에 대해서 다룹니다.

### 1) 토큰화(Tokenization)

자연어 처리에서 크롤링 드응로 얻어낸 코퍼스 데이터가 필요에 맞게 전처리됮 않은 상태라면, 해당 데이터를 사용하고자하는 용도에 맞게 토큰화, 정제, 정규화 하는 일을 하게 됩니다. 이번에는 그 중에서도 토큰화에 대해서 학습합니다. 

주어진 코퍼스에서 토큰이라 불리는 단위로 나누는 작업을 토큰화라고 합니다. 토큰의 단위가 상황에 따라 다르지만, 보통 의미있는 단위로 토큰을 정의합니다. 여기서는 토큰화에 대한 발생할 수 있는 여러가지 상황에 대해서 언급하여 토큰화에 댛나 캐념을 이해합니다. 이어서 NLTK, KoNLPy를 통해 실습을 진행하며 토큰화를 수행합니다.

#### 1. 단어 토큰화(Word Tokenizaion)

토큰의 기준을 단어(Word)로 하는 경우, 단어 토큰화라고 합니다. 다만, 여기서 단어는 단어 단위 외에도 단어구, 의미를 갖는 문자열로도 간주되기도 합니다.

예를들어 아래의 입력으로부터 구두점(마침표, 쉼표, 물음표, 느낌표, 세미클론 등)과 같은 문자는 제외시키는 간단한 단어 토큰화 작업을 해봅십다.

입력 : Time is an illusion. Lunchtime double so!

이러한 입력으로부터 구두점을 제외시킨 토큰화 작업의 결과는 다음과 같습니다.

출력 : "Time", "is", "an", "illusion", "Lunchtime", "double", "so"

보통 토큰화 작업은 단순히 구두점이나 특수문자를 전부 제거하는 정제작업을 수행하는 것만으로 해결되지 않습니다. 구두점이나 특수문자를 전부 제거하면 토큰이 의미를 잃어버리는 경우가 발생하기도 합니다. 심지어 띄어쓰기 단위로 자르면 사실상 단어 톸느이 구분되는 영어와 달리, 한국어는 띄어쓰기만으로는 단어 토큰을 구분하기 어렵습니다.

#### 2. 토큰화 중 생기는 선택의 순간

토큰화를 하다보면, 예상하지 못한 경우가 있어서 토큰화의 기준을 생각해봐야하는 경우가 발생합니다. 물론, 이러한 선택은 해당 ㄷ이터를 가지고 어떤 용도로 사용할 것인지에 따라서 그 용도에 영향이 없는 기준으로 정하면 됩니다. 예를들어 영어권 언어에서 아포스트로피(')가 들어가있는 단어는 어떻게 토큰으로 분류해야 하는지에 대한 선택의 문제를 보여드리겠습니다. 

다음과 같은 문장이 있다고 해봅시다.  
`Don't be fooled by the dark sounding name, Mr.Jone's Orphanage is as cheery as cheery goes for a pastry shop.`

아포스트로피가 들어간 상황에서 Don't와 Jone's는 어떻게 토큰화할 수 있는지 보겠습니다.
"Don't", "Don t", "Dont", "Do n't","Jone's", "Jone s", "Jone", "Jones"

이 중 사용자가 원하는 결과가 나오도록 토큰화 도구를 직접 설계할 수도 있겠지만, 기존의 공개된 도구들을 사용하였을 때의 결과가 사용자의 목적과 일치한다면 해당 도구를 사용할 수도 있을 것ㅇ비니다. NLTK는 영어 코퍼스를 토큰화하기 위한 도구들을 제공합니다. 그 중 word_tokenize와 WordPunctTokenizer를 사용해서 아포스트로피를 어떻게 처리하는지 확인해보겠습니다.


```python
from nltk.tokenize import word_tokenize
from nltk.tokenize import WordPunctTokenizer
from tensorflow.keras.preprocessing.text import text_to_word_sequence
```


```python
# 이전에 import nltk, nltk.download('punkt')를 아나콘다크롬프트에 해주자!

print('단어 토큰화1 : ', word_tokenize("Don't be fooled by the dark sounding name, Mr. Jone's Orphanage is as cheery as cheery goes for a pastry shop."))
```

    단어 토큰화1 :  ['Do', "n't", 'be', 'fooled', 'by', 'the', 'dark', 'sounding', 'name', ',', 'Mr.', 'Jone', "'s", 'Orphanage', 'is', 'as', 'cheery', 'as', 'cheery', 'goes', 'for', 'a', 'pastry', 'shop', '.']
    

word_toenize는 Don't를 Do와 n't로 분리하였으며, 반면 Jone's는 Jone과 's로 분리한 것을 확인할 수 있습니다.


```python
print('단어 토큰화2 : ', WordPunctTokenizer().tokenize("Don't be fooled by the dark sounding name, Mr. Jone's Orphanage is as cheery as cheery goes for a pastry shop."))
```

    단어 토큰화2 :  ['Don', "'", 't', 'be', 'fooled', 'by', 'the', 'dark', 'sounding', 'name', ',', 'Mr', '.', 'Jone', "'", 's', 'Orphanage', 'is', 'as', 'cheery', 'as', 'cheery', 'goes', 'for', 'a', 'pastry', 'shop', '.']
    

WordPunctTokenizer는 구두점을 별도로 분류하는 특징을 갖고 있기 때문에, Don't를 Don ' t로 분리하였으며, 마찬가지로 Jone's를 Jone ' s로 분리한 것을 확인할 수 있습니다. 케라스 또한 토큰화 도구로서 text_to_word_sequence를 지원합니다.


```python
print('단어 토큰화3 : ', text_to_word_sequence("Don't be fooled by the dark sounding name, Mr. Jone's Orphanage is as cheery as cheery goes for a pastry shop. "))
```

    단어 토큰화3 :  ["don't", 'be', 'fooled', 'by', 'the', 'dark', 'sounding', 'name', 'mr', "jone's", 'orphanage', 'is', 'as', 'cheery', 'as', 'cheery', 'goes', 'for', 'a', 'pastry', 'shop']
    

케라스의 text_to_word_sequence는 기본적으로 모든 알파벳을 소문자로 바꾸면서 마침표나 쉼표, 느낌표 등의 구두점을 제거합니다. 하지만 Don't나 Jone's와 같은 경우 아포스트로피는 보존하는 것을 볼 수 있습니다.

#### 3. 토큰화에서 고려해야할 사항

토큰화 작업을 단순하게 코퍼스에서 구두점을 제외하고 공백 기준으로 잘라내는 작업이라고 간주할 수는 없습니다. 이러한 일은 보다 섬세한 알고리즘이 필요한데 그 이유를 정리해봅시다.

##### (1) 구두점이나 특수 문자를 단순 제외해서는 안 된다.

갖고있는 코퍼스에서 단어들을 걸러낼 때, 구두점이나 특수 문자를 단순히 제외하는 것은 옳지 않습니다. 코퍼스에 대한 정제 작업을 진행하다보면, 구두점조차도 하나의 토큰으로 분류하기도 합니다. 가장 기본적인 예를 들어보자면, 마침표와 같은 경우에는 문장의 경계를 알 수 있는데 도움이 되므로 단어를 뽑아낼 때, 마침표를 제외하지 않을 수 있습니다.

##### (2) 줄임말과 단어 내에 띄어쓰기가 있는 경우.

토큰화 작업에서 종종 영어권 언어의 아포스트로피는 압축된 단어를 다시 펼치는 역할을 하기도 합니다. 예를들어 what're는 waht are의 줄임말이며, we're는 we are의 줄임말입니다. 위의 예에서 re를 접어(clitic)라고 합니다. 즉, 단어가 줄임말로 쓰일 때 생기는 형태를 말합니다. 

New York이라는 단어나 rock'n roll이라는 단어를 봅시다. 이 단어들은 하나의 단어이지만 중간에 띄어쓰기가 존재합니다. 사용 용도에 따라서, 하나의 단어 사이에 띄어쓰기가 있는 경우에는 하나의 토큰으로 봐야하는 경우도 있을 수 있으므로, 토큰화 작업은 저러한 단어를 하나로 인식할 수 있는 능력도 가져야합니다.

##### (3) 표준 토큰화 예제

이해를 돕기 위해 표준으로 쓰이고 있는 토큰화 방법 중 하나인 Penn Treebank Tokenization 의 규칙에 대해서 소개하고, 토큰화의 결과를 확인해보겠습니다.

* 규칙 1. 하이푼(-)으로 구성된 단어는 하나로 유지한다.
* 규칙 2. doesn't와 같이 아포스트로피(')로 접어가 함께하는 단어는 분리해준다.

해당 표준에 아래의 문장을 입력으로 넣어봅시다.  
`"Starting a home-based restaurant may be an ideal. it doesn't have a food chainor restaurant of their own"`


```python
from nltk.tokenize import TreebankWordTokenizer

tokenizer = TreebankWordTokenizer()

text = """Starting a home-based restaurant may be an ideal. it doesn't have a food
chainor restaurant of their own"""

print('트리뱅크 워드토크나이저 : ', tokenizer.tokenize(text))
```

    트리뱅크 워드토크나이저 :  ['Starting', 'a', 'home-based', 'restaurant', 'may', 'be', 'an', 'ideal.', 'it', 'does', "n't", 'have', 'a', 'food', 'chainor', 'restaurant', 'of', 'their', 'own']
    

결과를 보면, 각각 규칙1과 규칙2에 따라서 home-based는 하나의 토큰으로 취급하고 있으며, donsen't의 경우 does와 n't로 분리되었음을 볼 수 있습니다.

#### 4. 문장 토큰화(Sentence Tokenization)

이번에는 토큰의 단위가 문장(Sentence)일 경우를 논의해보겠습니다. 이 작업은 갖고있는 코퍼스 내에서 문장 단위로 구분하는 작업으로 때로는 문장 분류(sentence segmentation)라고도 부릅니다. 보통 갖고있는 코퍼스가 정제되지 않은 상태라면, 코퍼스는 문장 단위로 구분되어 있지 않아서 이를 사용하고자 하는 용도에 맞게 문장 토큰화가 필요할 수 있습니다.

직관적으로 생각해봤을 때는 ?나 마침표나 ! 기준으로 문장을 잘라내면 주어진 코퍼스로부터 문장 단위로 분류할 수 있지 않을까 싶지만, 꼭 그렇지만은 않습니다. !나 ?는 문장의 구분을 위한 꽤 명확한 구분자(boundary) 역할을 하지만 마침표는 그렇지 않기 때문입니다. 마침표는 문장의 끝이 아니더라도 등장할 수 있습니다.

예 : `IP 192.168.56.31 서버에 들어가서 로그 파일 저장해서 ass@gmail.com로 결과 좀 보내줘. 그 후 점심 먹으러 가자.`

위의 예제에 마침표를 기준으로 문장 토큰화를 적용해본다면 보내줘.에서 처음으로 문장이 끝난 것으로 인식하는 것이 제대로 문장의 끝을 예측했다고 볼 수 있습니다. 하지만 단순히 마침표로 문장을 구분짓는다고 가정하면, 문장의 끝이 나오기 전에 이미 마침표가 여러번 등장하여 예상한 결과가 나오지 않게 됩니다. 

사용하는 코퍼스가 어떤 국적의 언어인지, 또는 해당 코퍼스 내에서 특수문자들이 어떻게 사용되고 있는지에 따라서 직접 규칙들을 정의해볼 수 있습니다. 100% 정확도를 얻는 일은 쉬운 일이 아닌데, 갖고있는 코퍼스 데이터에 오타나, 문장의 구성이 엉망이라면 정해놓은 규칙이 소용이 없을 수 있기 때문입니다. 

NLTK에서는 영어 문장의 토큰화를 수행하는 sent_tokenize를 지원하고 있습니다. NLTK를 통해 문장 토큰화를 실습해보겠습니다.


```python
from nltk.tokenize import sent_tokenize

text = "His barber kept his word. But keeping such a huge secret to himself was driving him craze. Finally, the barber went up a mountain and almost to the edge of a cliff. He dug a hole in the midst of some reeds. He looked about, to mak sure no ne was near."

print('문장 토큰화1 : ', sent_tokenize(text))
```

    문장 토큰화1 :  ['His barber kept his word.', 'But keeping such a huge secret to himself was driving him craze.', 'Finally, the barber went up a mountain and almost to the edge of a cliff.', 'He dug a hole in the midst of some reeds.', 'He looked about, to mak sure no ne was near.']
    

위 코드는 text에 저장된 여러 개의 문장들로부터 문장을 구분하는 코드입니다. 출력 결과를 보면 성공적으로 모든 문장을 구분해내었음을 볼 수 있습니다. 그렇다면 이번에는 문장 중간에 마침표가 다수 등장하는 경우에 대해서도 실습해보겠습니다.


```python
text = "I am actively looking forPh.D students. and you ar a Ph.D student."

print("문장 토큰화2 : ", sent_tokenize(text))
```

    문장 토큰화2 :  ['I am actively looking forPh.D students.', 'and you ar a Ph.D student.']
    

NLTK는 단순히 마침표를 구분자로 하여 문장을 구분하지 않았기 때문에, PH.D를 문장 내의 단어로 인식하여 성공적으로 인식하는 것을 볼 수 있습니다.  

한국어에 대한 문장 토큰화 도구 또한 존재합니다. 한국어의 경우에는 박상길님이 개발한 KSS(Korean Sentence Splitter)를 추천합니다. 다음과 같이 KSS를 설치합니다.

```python
pip install kss
```


```python
import kss

text = '딥 러닝 자연어 처리가 재미있기는 합니다. 그런데 문제는 영어보다 한국어로 할 때 너무 어렵습니다. 이제 해보면 알걸요?'
print('한국어 문장 토큰화 : ',kss.split_sentences(text))
```

    [Korean Sentence Splitter]: Initializing Pynori...
    

    한국어 문장 토큰화 :  ['딥 러닝 자연어 처리가 재미있기는 합니다.', '그런데 문제는 영어보다 한국어로 할 때 너무 어렵습니다.', '이제 해보면 알걸요?']
    

#### 5. 한국어에서의 토큰화의 어려움.

영어는 New York과 같은 합성어나 he's 와 같은 줄임말에 대한 예외처리만 한다면, 띄어쓰기를 기준으로 하는 띄어쓰기 토큰화를 수행해도 단어 토큰화가 잘 작동합니다. 거의 대부분의 경우에서 단어 단위로 띄어쓰기가 이루어지기 때문에 띄어쓰기 토큰화에 단어 토큰화가 거의 같기 때문입니다.

하지만 한국어는 영어와는 달리 띄어쓰기만으로는 토큰화를 하기에 부족합니다. 한국어의 경우에는 띄어쓰기 단위가 되는 단위를 `어절`이라고 하는데 어절 토큰화는 한국어 NLP에서 지양되고 있습니다. 어절 토큰화와 단어 토큰화는 같지 않기 때문입니다. 그 근본적인 이유는 한국어가 영어와는 다른 형태를 가지는 언어인 교착어라는 점에서 기인합니다. 교착어란 조사, 어미 등을 붙여서 말을 만드는 언어를 말합니다.

##### (1) 교착어의 특성

영어와는 달리 한국어에는 조사라는 것이 존재합니다. 예를들어 한국에 그라는 주어나 목적어가 들어간 문장이 있다고 합시다. 이 경우, 그라는 단어 하나에도 '그가', '그에게', '그를', '그는' 과 같이 다양한 조사가 '그'라는 글자 뒤에 띄어쓰기 없이 바로 붙게 됩니다. 자연어 처리를 하다보면 같은 단어임에도 서로 다른 조사가 붙어서 다른 단어로 인식이 되면 자연어 처리가 힘들고 번거로워지는 경우가 많습니다. 대부분의 한국어 NLP에서 조사는 분리해줄 필요가 있습니다.  

띄어쓰기 단위가 영어처럼 독립적인 단어라면 띄어쓰기 단위로 토큰화를 하면 되겠지만 한국어는 어절이 독립적인 단어로 구성되는 것이 아니라 조사 등의 무언가가 붙어있는 경우가 많아서 이를 전부 분리해줘야 한다는 의미입니다.

한국어 토큰화에서는 `형태소(morpheme)`라는 개념을 반드시 이해해야 합니다. 형태소란 뜻을 가진 가장 작은 말의 단위를 말합니다. 이 형태소에는 두 가지 형태소가 있는데 잘비 형태소와 의존 형태소입니다. 

* `자립 형태소` : 접사, 어미, 조사와 상관없이 자립하여 사용할 수 있는 형태소. 그 자체로 단어가 된다. 체언(명사, 대명사, 수사), 수식언(관형사, 부사), 감탄사 등이 있다.
* `의존 형태소` : 다른 형태소와 결합하여 사용되는 형태소. 접사, 어미, 조사, 어간 등을 말한다.

예를들어 다음과 같은 문장이 있다고 합시다.

* 문장 : 에디가 책을 읽었다.

이 문장을 띄어쓰기 단위로 토큰화를 수행한다면 다음과 같은 결과를 얻습니다.  
`'에디가', '책을', '읽었다']`  
하지만 이를 형태소 단위로 분해하면 다음과 같습니다.  
자립 형태소 : 에디, 책  
의존 형태소 : -가, -을, 읽-, -었, -다 

'에디'라는 사람 이름과 '책'이라는 명사를 얻어낼 수 있습니다. 이를 통해 유추할 수 있는 것은 한국어에서 영어에서의 단어 토큰화와 유사한 형태를 얻으려면 어절 토늨화가 아니라 형태소 토큰화를 수행해야 한다는 겁니다.  

##### (2) 한국어는 띄어쓰기가 영어보다 잘 지켜지지 않는다.  

사용하는 한국어 코퍼스가 뉴스 기사와 같이 띄어쓰기를 철저하게 지키려고 노력하는 글이라면 좋겠지만, 많은 경우에 띄어쓰기가 틀렸거나 지켜지지 않는 코퍼스가 많습니다.  

한국어는 영어권 언어와 비교하여 띄어쓰기가 어렵고 잘 지켜지지 않는 경향이 있습니다. 그 이유는 여러 견해가 있으나, 가장 기본적인 견해는 한국어의 경우 띄어쓰기가 지켜지지 않아도 글을 쉽게 이해할 수 있는 언어라는 점입니다.

#### 6. 품사 태깅(Part-of-speech tagging)

단어는 표기는 같지만 품사에 따라서 단어의 의미가 달라지기도 합니다. 예를 들어서 영어 단어 'fly'는 동사로는 '날다'라는 의미를 갖지만, 명사로는 '파리'라는 의미를 갖고있습니다. 한국어도 마찬가집니다. '못'이라는 단어는 명사로서는 망치를 사용해서 목재 따위를 고정하는 물건을 의미합니다. 하지만 부사로서의 '못'은 '먹는다', '달린다'와 같은 동작 동사를 할 수 없다는 의미로 쓰입니다. 결국 단어의 의미를 제대로 파악하기 위해서는 해당 단어가 어떤 품사로 쓰였는지 보는 것이 주요 지표가 될 수도 있습니다. 그에 따라 <u>단어 토큰화 과정에서 각 단어가 어떤 품사로 쓰였는지를 구분해놓기도 하는데</u>, 이 작업을 `품사 태킹(part-of-speech tagging)`이라고 합니다.

#### 7. NLTK와 KoNLPy를 이용한 영어, 한국어 토큰화 실습

NLTK에서는 Penn Treebank POS Tags라는 기준을 사용하여 품사를 태깅합니다. [링크](https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html)


```python
# 이전에 import nltk, nltk.download('averaged_perceptron_tagger')를 아나콘다크롬프트에 해주자!

from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag

text = "I am actively looking for Ph.D. students. and you are a Ph.D. student."
tokenized_sentence = word_tokenize(text)

print('단어 토큰화 : ', tokenized_sentence)
print('품사 태킹 : ',pos_tag(tokenized_sentence))
```

    단어 토큰화 :  ['I', 'am', 'actively', 'looking', 'for', 'Ph.D.', 'students', '.', 'and', 'you', 'are', 'a', 'Ph.D.', 'student', '.']
    품사 태킹 :  [('I', 'PRP'), ('am', 'VBP'), ('actively', 'RB'), ('looking', 'VBG'), ('for', 'IN'), ('Ph.D.', 'NNP'), ('students', 'NNS'), ('.', '.'), ('and', 'CC'), ('you', 'PRP'), ('are', 'VBP'), ('a', 'DT'), ('Ph.D.', 'NNP'), ('student', 'NN'), ('.', '.')]
    

영어 문장에 대해서 토큰화를 수행한 결과를 입력으로 품사 태깅을 수행하였습니다. Penn Treebank POS tags에서 PRP는 인칭 대명사, VBP는 동사, RB는 부사, VBG는 현재부사, IN은 전치사, NNP는 고유 명사, NNS는 복수형 명사, CC는 접속사, DT는 관사를 의미합니다.

한국어 자연어 처리를 위해서는 KoNLPy라는 파이썬 패키지를 사용할 수 있습니다. KoNLPy를 통해서 사용할 수 있는 현태소 분석기로 OKT(Open Korea Text), 메캅(Mecab), 코모란(Komoran), 한나눔(Hannanum), 꼬꼬마(KKMa)가 있습니다.

한국어 NLP에서 형태소 분석기를 사용하여 단어 토큰화. 더 정확히는 형태소 토큰화(morpheme tokenization)를 수행해보겠습니다. 여기서는 OKT와 꼬꼬마 두 개의 형태소 분석기를 사용하여 토큰화를 수행하겠습니다.

[링크](https://data-scientist-brian-kim.tistory.com/79)


```python
from konlpy.tag import Okt
from konlpy.tag import Kkma

okt = Okt()
kkma = Kkma()

print('OKT 형태소 분석 : ', okt.morphs("열심히 코딩한 당신, 연휴에는 여행을 가봐요"))
print('OKT 품사 태깅 : ', okt.pos("열심히 코딩한 당신, 연휴에는 여행을 가봐요"))
print('OKT 명사 추출 : ', okt.nouns("열심히 코딩한 당신, 연휴에는 여행을 가봐요"))
```

    OKT 형태소 분석 :  ['열심히', '코딩', '한', '당신', ',', '연휴', '에는', '여행', '을', '가봐요']
    OKT 품사 태깅 :  [('열심히', 'Adverb'), ('코딩', 'Noun'), ('한', 'Josa'), ('당신', 'Noun'), (',', 'Punctuation'), ('연휴', 'Noun'), ('에는', 'Josa'), ('여행', 'Noun'), ('을', 'Josa'), ('가봐요', 'Verb')]
    OKT 명사 추출 :  ['코딩', '당신', '연휴', '여행']
    

위의 예제는 OKT 형태소 분석기로 토큰화를 시도해본 예제입니다. 각각의 메소드는 아래와 같은 기능을 갖고 있습니다.

* morphs : 형태소 추출  
* pos : 품사 태킹(Part-of-speech tagging)  
* nouns : 명사 추출  

앞서 언급한 KoNLPy의 형태소 분석기들은 공통적으로 이 메소드들을 제공하고 있습니다. 위 예제에서 형태소 추출과 품사 태깅 메소드의 결과를 보면 조사를 기본적으로 분리하고 있음을 확인할 수 있습니다. 한국어 NLP에서 전처리에 형태소 분석기를 사용하는 것은 굉장히 유용합니다. 이번에는 꼬꼬마 형태소 분석기를 사용하여 같은 문장에 대해서 토큰화를 진행해보겠습니다.


```python
print('꼬꼬마 형태소 분석 : ', kkma.morphs('열심히 코딩한 당신, 연휴에는 여행을 가봐요'))
print('꼬꼬마 품사 태깅 : ', kkma.pos('열심히 코딩한 당신, 연휴에는 여행을 가봐요'))
print('꼬꼬마 명사 추출 : ', kkma.nouns('열심히 코딩한 당신, 연휴에는 여행을 가봐요'))
```

    꼬꼬마 형태소 분석 :  ['열심히', '코딩', '하', 'ㄴ', '당신', ',', '연휴', '에', '는', '여행', '을', '가보', '아요']
    꼬꼬마 품사 태깅 :  [('열심히', 'MAG'), ('코딩', 'NNG'), ('하', 'XSV'), ('ㄴ', 'ETD'), ('당신', 'NP'), (',', 'SP'), ('연휴', 'NNG'), ('에', 'JKM'), ('는', 'JX'), ('여행', 'NNG'), ('을', 'JKO'), ('가보', 'VV'), ('아요', 'EFN')]
    꼬꼬마 명사 추출 :  ['코딩', '당신', '연휴', '여행']
    

앞서 사용한 OKT 형태소 분석기와 결과가 다른 것을 볼 수 있습니다. 각 형태소 분석기는 성능과 결과가 다르게 나오기 때문에, 현태소 분석기의 선택은 사용하고자 하는 필요 용도에 어떤 형태소 분석기가 가장 적절한지를 판단하고 사용하면 됩니다. 


### 2) 정제(Cleaning)와 정규화(Normalization)

코퍼스에서 용도에 맞게 토큰을 분류하는 작업을 토큰화라고 하며, 토큰화 작업 전, 후에는 텍스트 데이터를 용도에 맞게 정제 및 정규화하는일이 항상 함께합니다. 정제 및 정규화의 목적은 각각 다음과 갖습니다.

* 정제(cleaning) : 갖고 있는 코퍼스로부터 노이즈 데이터를 제거한다.
* 정규화(Normalization) : 표현 방법이 다른 단어들을 통합시켜서 같은 단어로 만들어준다.

정제 작업은 토큰화 작업에 방해가 되는 부분들을 배제시키고 토큰화 작업을 수행하기 위해서 토큰화 작업보다 앞서 이루어지기도 하지만, 토큰화 작업 이후에도 여전히 남아있는 노이즈들을 제거하기위해 지속적으로 이루어지기도 합니다. 완벽한 정제 작업은 어려운 편이라서, 대부분의 경우 일종의 합의점을 찾기도 합니다.

#### 1. 규칙에 기반한 표기가 다른 단어들의 통합

필요에 따라 직접 코딩을 통해 정의할 수 있는 정규화 규틱의 예로서 같은 의미를 갖고있음에도, 표기가 다른 단어들을 하나의 단어로 정규화하는 방법을 사용할 수 있습니다.

가령, USA와 US는 같은 의미를 가지므로 하나의 단어로 정규화해볼 수 있습니다. uh-huh와 uhhuh는 형태는 다르지만 여전히 같은 의미를 갖고 있습니다. 이러한 정규활르 거치게 되면, US를 찾아도 USA도 함께 찾을 수 있을 것입니다. 뒤에서 표기가 다른 단어들을 통합하는 방법인 어간 추출(stemming)과 표제어 추출(lemmatization)에 대해서 더 자세히 알아봅니다.

#### 2. 대, 소문자 통합

영어권 언어에서 대, 소문자를 통합하는 것은 단어의 개수를 줄일 수 잇는 또 다른 정규화 방법입니다. 영어권 언어에서 대문자는 문장의 맨 앞 등과 같은 특정 상황에서만 쓰이고, 대부분의 글은 손문자로 작성되기 때문에 대, 소문자 통합 작업은 대부분 대문자를 소문자로 변환하는 소문자 변환작업으로 이루어지게 됩니다.

소문자 변환이 왜 유용한지 예를 들어보도록 하겠습니다. 가령, Automobile이라는 단어가 문장의 첫 단어였기 때문에 A가 대문자였다고 생각해봅시다. 여기에 소문자 변환을 사용하면, automobile을 찾는 질의의 결과로서 Automobile도 찾을 수 있게 됩니다. 

물론 대문자와 소문자를 무작정 통합해서는 안 됩니다. 대문자와 소문자가 구분되어야 하는 경우도 있습니다. 가령 미국을 뜻하는 단어 US와 우리를 뜻하는 us는 구분되어야 합니다.

모든 토큰을 소문자로 만드는 것이 문제를 가져온다면, 또 다른 대안은 일부만 소문자로 변환시키는 방법도 있습니다. 문장의 맨 앞에서 나오는 단어의 대문자만 소문자로 바꾸고, 다른 단어들을 전부 대문자인 상태로 놔두는 것입니다.

이러한 작업은 더 많은 변수를 사용하여 소문자 변환을 언제 사용할지 결정하는 머신 러닝 시퀀스 모델로 더 정확하게 진행시킬 수 있습니다. 하지만 만약 올바른 대문자 단어를 얻고 싶은 상황에서 훈련에 사용하는 코퍼스가 사용자들이 단어의 대문자, 소문자의 올바른 사용 방법과 상관없이 소문자를 사용하는 사람들로부터 나온 데이터라면 이러한 방법 또한 그다지 도움이 되지 않을 수 있습니다. 결국에는 예외 사항을 크게 고려하지 않고, 모든 코퍼스를 소문자로 바꾸는 것이 종종 더 실용적인 해결책이 되기도 합니다. 

#### 3. 불필요한 단어의 제거

정제 작업에서 제거해야하는 노이즈 데이터는 자연어가 아니면서 아무 의미도 갖지 않는 글자들(특수 문자 등)을 의미하기도 하지만, 분석하고자 하는 목적에 맞지 않는 불필요 단어들을 노이즈 데이터라고 하기도 합니다.

불필요 단어들을 제거하는 방법으로는 불용어 제거와 등장 빈도가 적은 단어, 길이가 짧은 단어들을 제거하는 방법이 있습니다. 불용어 제거는 불용어 챕터에서 더욱 자세히 다루기로 하고, 여기서는 등장 빈도가 적은 단어와 길이가 짧은 단어를 제거하는 경에 대해서 간략히 설명하겠습니다.

##### (1) 등장 빈도가 적은 단어

때로는 텍스트 데이터에서 너무 적게 등장해서 자영어 처리에 도움이 되지 않는 단어들이 존재합니다. 예를 들어 입력된 메일이 정상 메일인지 스팸 메일인지를 분류하는 스팸 메일 분류기를 설계한다고 가정해보겠습니다. 총 100,000개의 메일을 가지고 정상 메일에서는 어떤 단어들이 주로 등장하고, 스팸 메일에서는 어떤 단어들이 주로 등장하는지를 가지고 설계하고자 합니다. 그런데 이때 100,000개의 메일 데이터에서 총 합 5번 밖에 등장하지 않는 단어가 있다면 이 단어는 직관적으로 분류에 거의 도움이 되지 않을 것임을 알 수 있습니다.

##### (2) 길이가 짧은 단어

영어권 언어에서는 길이가 짧은 단어를 삭제하는 것만으로도 어느정도 자연어 처리에서 크게 의미가 없는 단어들을 제거하는 효과를 볼 수 있다고 알려져 있습니다. 즉, 영어권 언어에서 길이가 짧은 단어들은 대부분 불용어에 해당됩니다. 사실 길이가 짧은 단어를 제거하는 2차 이유는 길이를 조건으로 텍스트를 삭제하면서 단어가 아닌 구두점들 까지도 한껗번에 제거하기 위함도 있습니다. 하지만 한국어에서는 길이가 짧은 단어라고 삭제하는 이런 방법이 크게 유효하지 않을 수 있는데 그 이유에 대해서 정리해보도록 하겠습니다.

단정적으로 말할 수는 없지만, 영어 단어의 평균 길이는 6\~7 정도이며, 한국어 단어의 평균 길이는 2\~3 정도로 추정되고 있습니다. 두 나라의 단어 평균 길이가 몇 인지에 대해서는 확실히 말하기 어렵지만 그럼에도 확실한 사실은 영어 단어의 길이가 한국어 단어의 길이보다는 평균적으로 길다는 점입니다.

이는 영어 단어와 한국어 단어에서 각 한 글자가 가진 의미의 크기가 다르다는 점에서 기인합니다. 한국어 단어는 한자어가 많고, 한 글자만으로도 이미 의미를 가진 경우가 많습니다. 

이러한 특성으로 인해 영어는 길이가 2\~3 이하인 단어를 제거하는 것만으로도 크게 의미를 갖지 못하는 단어를 줄이는 효과를 갖고있습니다. 예를 들어 갖고 있는 텍스트 데이터에서 길이가 1인 단어를 제거하는 코드를 수행하면 대부분의 자연어 처리에서 의미를 갖지 못하는 단어인 관사 'a'와 주어로 쓰이는 'I'가 제거됩니다. 필요에 따라서는 길이가 3인 단어도 제거할 수 있지만, 이 경우 fox, dog, car 등 길이가 3인 명사들이 제거 되기 시작하므로 사용하고자 하는 데이터에서 해당 방법을 사용해도 되는지에 대한 고민이 필요합니다.


```python
import re

text = "I was wondering if anyone out there could enlighten me on this car."

# 길이가 1~2인 단어들을 정규 표현식을 이용하여 삭제
shorword = re.compile(r'\w*\b\w{1,2}\b')
print(shorword.sub('', text))
```

     was wondering  anyone out there could enlighten   this car.
    

#### 4. 정규 표현식(Regular Expression)

얻어낸 코퍼스에서 노이즈 데이터의 특징을 잡아낼 수 있다면, 정규 표현식을 통해서 이를 제거할 수 있는 경우가 많습니다. 가령, HTML 문서로부터 가져온 코퍼스라면 여기저기에 HTML 태그가 있습니다. 뉴스 기사를 크롤링 했다면, 기사마다 게재 시간이 적혀져 있을 수 있습니다. 정규 표현식은 이러한 코퍼스 내에 계속해서 등장하는 글자들을 규칙에 기반하여 한 번에 제거하는 방식으로서 매우 유용합니다.

정규 표현식에 대한 자세한 내용은 뒤에서 좀 더 상세하게 다룹니다.

### 3) 어간 추출(Stemming)과 표제어 추출(Lemmatization)

정규화 기법 중 코퍼스에 있는 단어의 개수를 줄일 수 있는 기법인 표제어 추출과 어간 추출의 개념에 대해서 알아봅니다. 또한 이 둘의 결과가 어떻게 다른지 이해합니다.

이 두 작업이 갖고 있는 의미는 눈으로 봤을 때는 서로 다른 단어들이지만, 하나의 단어로 일반화시킬 수 있다면 하나의 단어로 일반화시켜서 문서 내의 단어 수를 줄이겠다는 것입니다. 이러한 방법들은 단어의 빈도수를 기반으로 문제를 풀고자 하는 뒤에서 학습하게 될 BoW(Bag of Words) 표현을 사용하는 자연어 처리 문제에서 주로 사용됩니다. 자연어 처리에서 전처리, 더 정확히는 정규화의 지향점은 언제나 갖고 있는 코퍼스로부터 복잡성을 줄이는 일입니다. 

#### 1. 표제어 추출(Lemmatization)

표제어는 한글로는 '표제어' 또는 '기본 사전형 단어' 정도의 의미를 갖습니다. 표제어 추출은 단어들로부터 표제어를 찾아가는 과정입니다. 표제어 추출은 단어들이 다른 형태를 가지더라도, 그 뿌리 단어를 찾아가서 단어의 개수를 줄일 수 있는지 판단합니다. 예를 들어서 am, arem is는 서로 다른 스펠링이지만 그 뿌리 단어는 be라고 볼 수 있습니다. 이때, 이 단어들의 표제어는 be라고 합니다.

표제어 추출을 하는 가장 섬세한 방법은 단어의 형태학적 파싱을 먼저 진행하는 것입니다. 형태소란 '의미를 가진 가장 작은 단위'를 뜻합니다. 그리고 형태학(morphology)이란 형태소로부터 단어들을 만들어가는 학문을 뜻합니다. 형태소의 종류로는 어간(stem)과 접사(affix)가 존재합니다.

* 어간(stem) : 단어의 의미를 담고 있는 단어의 핵심 부분.
* 접사(affix) : 단어의 추가적인 의미를 주는 부분.

형태학적 파싱은 이 두 가지 구성 요소를 분리하는 작업을 말합니다. 가령, cats라는 단어에 대해 형태학적 파싱을 수행한다면, 형태학적 파싱은 결과로 cat(어간)과 -s(접사)를 분리합니다. 꼭 두 가지로 분리되지 않는 경우도 있습니다. 단어 fox는 형태학적 파싱을 한다고 하더라도 더 이상 분리할 수 없습니다. fox는 독립적인 형태소이기 때문입니다. 이와 유사하게 cat 또한 더 이상 분리되지 않습니다. 

NLTK에서는 표제어 추출을 위한 도구인 WordNetLemmatizer를 지원합니다.


```python
# 이전에 import nltk, nltk.download('wordnet'), nltk.download('omw-1.4')를 아나콘다크롬프트에 해주자!

from nltk.stem import WordNetLemmatizer

lemmatizer = WordNetLemmatizer()

words = ['policy', 'doing', 'organzation', 'have', 'going', 'love', 'lives', 'fly', ' dies', 'watched', 'has', 'starting']

print('표제어 추출 전 : ', words)
print('표제어 추출 후 : ', [lemmatizer.lemmatize(word) for word in words])
```

    표제어 추출 전 :  ['policy', 'doing', 'organzation', 'have', 'going', 'love', 'lives', 'fly', ' dies', 'watched', 'has', 'starting']
    표제어 추출 후 :  ['policy', 'doing', 'organzation', 'have', 'going', 'love', 'life', 'fly', ' dies', 'watched', 'ha', 'starting']
    

표제어 추출은 뒤에서 언급할 어간 추출과는 달리 단어의 형태가 적절히 보존되는 양상을 보이는 특징이 있습니다. 하지만 그럼에도 위의 결과에서는 ha와 같이 의미를 알 수 없는 적절하지 못한 단어을 출력하고 있습니다. 이는 표제어 추출기가 본래 단어의 품사 정보를 알아야만 정확한 결과를 얻을 수 있기 때문입니다.

WordNetLemmatizer는 입력으로 단어가 동사 품사라는 사실을 알려줄 수 있습니다. 즉 dies와 watched, has가 문장에서 동사로 쓰였다는 것을 알려준다면 표제어 추출기는 품사의 정보를 보존하면서 정확한 Lemma를 출력하게 됩니다.



```python
print(lemmatizer.lemmatize('dies', 'v'))
print(lemmatizer.lemmatize('watched', 'v'))
print(lemmatizer.lemmatize('has', 'v'))
```

    die
    watch
    have
    

표제어 추출은 문맥을 고려하며 수행했을 때의 결과는 해당 단어의 품사 정보를 보존합니다. 하지만 어간 추출을 수행한 결과는 품사 정보가 보존되지 않습니다. 더 정확히는 어간 추출을 한 결과는 사전에 존재하지 않는 단어일 경우가 많습니다. 

#### 2. 어간 추출(Stemming)

어간을 추출하는 작업을 어간 추출이라고 합니다. 어간 추출은 형태학적 분석을 단순화한 버전이라고 볼 수도 있고, 정해진 규칙만 보고 단어의 어미를 자르는 얼미짐작의 작업이라고 볼 수도 있습니다. 이 작업은 섬세한 작업이 아니기 때문에 어간 추출 후에 나오는 결과 단어는 사전에 존재하지 않는 단어일 수도 있습니다. 예제를 보면 쉽게 이해할 수 있습니다. 어간 추출 알고리즘 중 하나인 포터 알고리즘에 아래의 문자열을 입력으로 넣는다고 해봅시다.

This was not the map we found in Billy Bones's chest, but an accurate copy, complete in all things--names and heights and soundings--with the single exception of the red crosses and the written notes.


```python
from nltk.stem import PorterStemmer
from nltk.tokenize import word_tokenize

stemmer = PorterStemmer()

sentence = "This was not the map we found in Billy Bones's chest, but an accurate copy, complete in all things--names and heights and soundings--with the single exception of the red crosses and the written notes."
tokenized_sentence = word_tokenize(sentence)

print('어간 추출 전 : ', tokenized_sentence)
print('어간 추출 후 : ', [stemmer.stem(word) for word in tokenized_sentence])
```

    어간 추출 전 :  ['This', 'was', 'not', 'the', 'map', 'we', 'found', 'in', 'Billy', 'Bones', "'s", 'chest', ',', 'but', 'an', 'accurate', 'copy', ',', 'complete', 'in', 'all', 'things', '--', 'names', 'and', 'heights', 'and', 'soundings', '--', 'with', 'the', 'single', 'exception', 'of', 'the', 'red', 'crosses', 'and', 'the', 'written', 'notes', '.']
    어간 추출 후 :  ['thi', 'wa', 'not', 'the', 'map', 'we', 'found', 'in', 'billi', 'bone', "'s", 'chest', ',', 'but', 'an', 'accur', 'copi', ',', 'complet', 'in', 'all', 'thing', '--', 'name', 'and', 'height', 'and', 'sound', '--', 'with', 'the', 'singl', 'except', 'of', 'the', 'red', 'cross', 'and', 'the', 'written', 'note', '.']
    

규칙 기반의 접을 하고 있으므로 어간 추출 후의 결과에는 사전에 없는 단어들도 포함되어 있습니다. 가령, 포터 알고리즘의 어간 추출은 이러한 규칙들을 가집니다.

* ALIZE - AL
* ANCE - 제거
* ICAL - IC  

Porter 알고리즘의 상세 규칙은 마틴 포터의 홈페이지에서 확인할 수 있습니다.  
[링크](https://tartarus.org/martin/PorterStemmer/)

위의 규칙에 따르면 좌측의 단어는 우측의 단어와 같은 결과를 얻게됩니다.

* formalize - formal
* allowance - allow
* electricical - electric


```python
words = ['formalize', 'allowance', 'electricical']

print('어간 추출 전 : ', words)
print('어간 추출 후 : ', [stemmer.stem(word) for word in words])
```

    어간 추출 전 :  ['formalize', 'allowance', 'electricical']
    어간 추출 후 :  ['formal', 'allow', 'electric']
    

어간 추출 속도는 표제어 추출보다 일반적으로 빠른데, 포터 어간 추출기는 정밀하게 설계되어 정확도가 높으므로 영어 자연어 처리에서 어간 추출을 하고자 한다면 가장 준수한 선택입니다. NLTK에서는 포터 알고리즘 외에도 랭커스터 스태머(Lancaster Stemmer)알고리즘을 지원합니다. 이번에는 포터 알고리즘과 랭커스터 스태머 알고리즘으로 각각 어간 추출을 진행했을 때, 이 둘의 결과를 비교해 보겠습니다.


```python
from nltk.stem import PorterStemmer
from nltk.stem import LancasterStemmer

porter_stemmer = PorterStemmer()
lancaster_stemmer = LancasterStemmer()

words = ['policy', 'doing', 'organization', 'have', 'going', 'love', 'lives', 'fly', 'dies', 'watched', 'has', 'starting']

print('어간 추출 전 : ', words)
print('포터 스테머의 어간 추출 후 : ', [porter_stemmer.stem(w) for w in words])
print('랭커스터 스테머의 어간 추출 후 : ', [lancaster_stemmer.stem(w) for w in words])
```

    어간 추출 전 :  ['policy', 'doing', 'organization', 'have', 'going', 'love', 'lives', 'fly', 'dies', 'watched', 'has', 'starting']
    포터 스테머의 어간 추출 후 :  ['polici', 'do', 'organ', 'have', 'go', 'love', 'live', 'fli', 'die', 'watch', 'ha', 'start']
    랭커스터 스테머의 어간 추출 후 :  ['policy', 'doing', 'org', 'hav', 'going', 'lov', 'liv', 'fly', 'die', 'watch', 'has', 'start']
    

동일한 단어들의 나열에 대해서 두 스태머는 전혀 다른 결과를 보여줍니다. 두 스태머 알고리즘은 서로 다른 알고리즘을 사용하기 때문입니다. 그렇기 때문에 이미 알려진 아록리즘을 사용할 때는, 사용하고자 하는 코퍼스에 스태머를 적용해보고 어떤 스태머가 해당 코퍼스에 적합한지를 판단단 후에 사용하여야 합니다. 

이런 규칙에 기반한 알고리즘은 종종 제대로 된 일반화를 수행하지 못 할 수 있습니다. 어간 추출을 하고나서 일반화가 지나치게 되거나, 또는 덜 되거나 하는 경우입니다. 예를 들어 포터 알고리즘에서 organization을 어간 추출했을 때의 결과를 봅시다.

organization - organ

organization과 organ은 완전히 다른 단어 임에도 organization에 대해서 어간 추출을 햇더니 organ이라는 단어가 나왔습니다. organ에 대해서 어간 추충을 한다고 하더라도 결과는 역시 organ이 되기 때문에, 두 단어에 대해서 어간 추출을 한다면 동일한 어간을 갖게 됩니다. 이는 의미가 동일한 경우에만 같은 단어를 얻기를 원하는 정규화의 목적에는 맞지 않습니다. 마지막으로 동일한 단어에 대해서 표제어 추출과 어간 추출을 각각 수행했을 때, 결과에서 어떤 차이가 있는지 간단한 예를 보겠습니다.

**Stemming**  
am - am  
the going - the go  
having - hav  

**Lemmatization**  
am - be  
the going - the going  
having - have  

#### 3. 한국어에서의 어간 추출  

한국어의 어간에 대해서 간략히 설명합니다. 한국어는 아래의 표와 같이 5언 9품사의 구조를 가지고 있습니다.

|**언**|**품사**|  
|:---|:---|  
|체언|명사, 대명사, 수사|
|수식언|관형사, 부사|
|관계언|조사|
|독립언|감탄사|
|**용언**|**동사, 형용사**|

이 중 용언에 해당하는 '동사'와 '형용사'는 어간(stem)과 어미(ending)의 결합으로 구성됩니다. 앞으로 용언이라고 언급하는 부분은 전부 동사와 형용사를 포함하여 언급하는 개념입니다.

##### (1) 활용(conjugation)

활용은 한국어에서만 가지는 특징이 아니라, 인도유럽어에서도 주로 볼 수 있는 언어적 특징 중 하나를 말하는 통칭적인 개념입니다. 다만, 여기서는 한국어에 한정하여 설명합니다.

활용이란 용언에 어간이 어미를 가지는 일을 말합니다.

**어간** : 용언(동사, 형용사)을 활용할 때, 원칙적으로 모양이 변하지 않는 부분. 활용에서 어미에 선행하는 부분. 때론 어간의 모양도 바뀔수 있음(예 : 긋다, 긋고, 그어서, 그어라).

**어미** : 용언의 어간 뒤에 붙어서 활용하면서 변하는 부분이며, 여러 문법적 기능을 수행

활용은 어간이 어미를 취할 때, 어간의 모습이 일정하다면 규칙 활용, 어간이나 어미의 모습이 변하는 불규칙 활용으로 나뉩니다.

##### (2) 규칙 활용

규칙 활용은 어간이 어미를 취할 때, 어간의 모습이 일정합니다. 아래으 ㅣ예제는 어ㅁ간과 어미가 합쳐질 때, 어간의 형태가 바뀌지 않음을 보여줍니다.

```
잡/어간 + 다/어미
```

이 경우에는 어간이 어미가 붙기전의 모습과 어미가 붙은 후의 모습이 같으므로, 규칙 기반으로 어미를 단순히 분리해주면 어간 추출이 됩니다.

##### (3) 불규칙 활용

불규칙 활용은 어간이 어미를 취할 때 어간의 모습이 바뀌거나 취하는 어미가 특수한 어미일 경우를 말합니다.

예를 들어 '듣-', '돕-', '곱-', '잇-', '오르-', '노랗-' 등이 '듣/들-', '돕/도우-', '곱/고우-', '잇/이-', '오르/올-', '노랗/노라-'와 같이 어간의 형식이 달라지는 일이 있거나 '오르 + 아/어 - 올라', '하 + 아/어 - 하여', '이르 + 아/어 - 이르러', '푸르 + 아/어 - 푸르러'와 같이 일반적읜 어미가 아닌 특수한 어미를 취하는 경우 불규칙활용을 하는 예에 속합니다. 

이 경우에는 어간이 어미가 붙는 과정에서 어간의 모습이 바귀었으므로 단순한 분리만으로 어간 추출이 되지 않고 좀 더 복잡한 규칙을 필요로 합니다.  

다양한 불규칙 활용의 예를 보고싶다면 [링크](https://namu.wiki/w/한국어/불규칙%20활용)를 활용하세요


### 4) 불용어(Stopword)

갖고 있는 데이터에서 유의미한 단어 토큰만을 선별하기 위해서는 큰 의미가 없는 단어 토큰을 제거하는 작업이 필요합니다. 여기서 큰 의미가 없다라는 것은 자주 등장하지만 분석을 하는 것에 있어서는 큰 도움이 되지 않는 단어들을 말합니다. 예를 들면, I, my, me, over, 조사, 접미사 같은 단어들은 문장에서는 자주 등장하지만실제 의미 분석을 하는데는 거의 기여하는 바가 없는 경우가 있습니다. 이러한 단어들을 불용어(stopword)라고 하며, NLTK에서는 위와 같은 100여개 이상의 영어 단어들을 불용어로 패키지 내에서 미리 정의하고 있습니다. 

물론 불용어가 개발자가 직접 정의할 수도 있습니다. 이번에는 영어 문장에서 NLTK가 정의한 영어 불용어를 제거하는 실습을 하고, 한국어 문장에서 직접 정의한 불용어를 제거해보겠습니다. 

NLTK 실습에서는 NLTK Data가 필요합니다


```python
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from konlpy.tag import Okt
```

#### 1. NLTK에서 불용어 확인하기


```python
# 이전에 import nltk, nltk.download('stopwords')를 아나콘다크롬프트에 해주자!

stop_words_list = stopwords.words('english')
print('불용어 개수 : ', len(stop_words_list))
print('불용어 10개 출력 : ', stop_words_list[:10])
```

    불용어 개수 :  179
    불용어 10개 출력 :  ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', "you're"]
    

stopwords.wotds('english')는 NLTK가 정의한 영어 불용어 리스트를 리턴합니다.

#### 2. NLTK를 통해서 불용어 제거하기


```python
example = "Family is not an important thing. It's everything."
stop_words = set(stopwords.words('english'))

word_tokens = word_tokenize(example)

result = []
for word in word_tokens:
    if word not in stop_words:
        result.append(word)
        
print('불용어 제거 전 : ', word_tokens)
print('불용어 제거 후 : ', result)
```

    불용어 제거 전 :  ['Family', 'is', 'not', 'an', 'important', 'thing', '.', 'It', "'s", 'everything', '.']
    불용어 제거 후 :  ['Family', 'important', 'thing', '.', 'It', "'s", 'everything', '.']
    

결과적으로 'is', 'not', 'an'과 같은 단어들이 문장에서 제거되었음을 볼 수 있습니다.

#### 3. 한국어에서 불용어 제거하기

한국어에서 불용어를 제거하는 방법으로는 간단하게는 토큰화 후에 조사, 접속사 등을 제거하는 방법이 있습니다. 하지만 불용어를 제거하려고 하다보면 조사나 접속사와 같은 단어들뿐만 아니라 명사, 형용사와 같은 단어들 중에서 불용어로서 제거하고 싶은 단어들이 생기기도 합니다. 이번에는 직접 불용어를 정의해보고, 주어진 문장으로부터 사용자가 정의한 불용어 사전으로부터 불용어를 제거해보겠습니다. 아래의 불용어는 임의 선정한 것으로 실제 의미있는 선정 기준이 아닙니다.


```python
okt = Okt()

example = "고기를 아무렇게나 구우려고 하면 안 돼. 고기라고 다 같은 게 아니거든. 예컨대 삼겹살을 구울 때는 중요한 게 있지."
stop_words = "를 아무렇게나 구 우려 고 안 돼 같은 게 구울 때 는"

stop_words = set(stop_words.split(' '))
word_tokens = okt.morphs(example)

result = [word for word in word_tokens if not word in stop_words]

print('불용어 제거 전 : ', word_tokens)
print('불용어 제거 후 : ', result)
```

    불용어 제거 전 :  ['고기', '를', '아무렇게나', '구', '우려', '고', '하면', '안', '돼', '.', '고기', '라고', '다', '같은', '게', '아니거든', '.', '예컨대', '삼겹살', '을', '구울', '때', '는', '중요한', '게', '있지', '.']
    불용어 제거 후 :  ['고기', '하면', '.', '고기', '라고', '다', '아니거든', '.', '예컨대', '삼겹살', '을', '중요한', '있지', '.']
    

아래의 링크는 보편적으로 선택할 수 있는 한국어 불용어 리스트를 보여줍니다. 하지만 여전히 절대적인 기준은 아닙니다.  

[링크](https://www.ranks.nl/stopwords/korean)

불용어가 많은 경우에는 코드 내에서 직접 정의하지 않고 txt 파일이나 csv 파일로 정리해놓고 이를 불러와서 사용하기도 합니다.

### 5) 정규 표현식(Regular Expression)

텍스트 전처리에서 정규 표현식은 아주 유용한 도구입니다. 이번에는 파이썬에서 지원하고 있는 정규 표현식 모듈 re의 사용 방법과 NLTK를 통한 정규 표현식을 이용한 토큰화에 대해서 알아봅니다.

#### 1. 정규 표현식 문법과 모듈 함수

파이썬에서는 정규 표현식 모듈 re을 지원하므로, 이를 이용하면 특정 규칙이 있는 텍스트 데이터를 빠르게 정제할 수 있습니다. 정규 표현식을 위해 사용되는 특수 문자와 모듈 함수에 대해서 표를 통해 정리해보겠습니다. 

##### 1) 정규 표현식 문법

정규 표현식을 위해 사용되는 문법 중 특수 문자들은 아래와 같습니다.

|**특수 문자**|**설명**|
|:---|:---|
|.|한 개의 임의의 문자를 나타냅니다. (줄바꿈 문자인 \n는 제외)|
|?|앞의 문자가 존재할 수도 있고, 존재하지 않을 수도 있습니다. (문자가 0개 또는 1개)|
|*|앞의 문자가 무한개로 존재할 수도 있고, 존재하지 않을 수도 있습니다. (문자가 0개 이상)|
|+|앞의 문자가 최소 한 개 이상 존재합니다. (문자가 1개 이상)|
|^|뒤의 문자열로 문자열이 시작됩니다.|
|$|앞의 문자열로 문자열이 끝납니다.|
|{숫자}|숫자만큼 반복합니다.|
|{숫자1, 숫자2}|숫자1 이상 숫자2 이하만큼 반복합니다. ?, *, +를 이것으로 대체할 수 있습니다.|
|{숫자,}|숫자 이상만큼 반복합니다.|
|[]|대괄호 안의 문자들 중 한 개의 문자와 매치합니다. [amk]라고 한다면 a 또는 m 또는 k 중 하나라도 존재하면 매치를 의미합니다. [a-z]와 같이 범위를 지정할 수도 있습니다. [a-zA-Z]는 알파벳 전체를 위미하는 범위이며, 문자열에 알파벳이 존재하면 매치를 의미합니다.|
|[^문자]|해당 문자를 제외한 문자를 매치합니다.|
|\||A\|B와 같이 쓰이며 A 또는 B의 의미를 가집니다.|

정규 표현식 문법에는 역 슬래쉬(\)를 이용하여 자주 쓰이는 문자 규칙들이 있습니다.

|**문자 규칙**|**설명**|
|:---|:---|
|\\|역 슬래쉬 문자 자체를 의미합니다.|
|\\d|모든 숫자를 의미합니다. [0-9]와 의미가 동일합니다.|
|\\D|숫자를 제외한 모든 문자를 의미합니다. [^0-9]와 의미가 동일합니다.|
|\\s|공백을 의미합니다. [\\t\\n\\r\\f\\v]와 의미가 동일합니다.|
|\\S|공백을 제외한 문자를 의미합니다. [^ \\t\\n\\r\\f\\v]와 의미가 동일합니다.|
|\\w|문자 또는 숫자를 의미합니다. [a-zA-Z0-9]와 의미가 동일합니다.|
|\\W|문자 또는 숫자가 아닌 문자를 의미합니다. [^ a-zA-Z0-9]와 의미가 동일합니다.|

##### 2) 정규 표현식 모듈 함수

정규 표현식 모듈에서 지원하는 함수는 이와 같습니다.

|**모듈 함수**|**설명**|
|:---|:---|
|re.compile()|정규 표현식을 컴파일하는 함수입니다. 다시 말해, 파이썬에게 전해주는 역할을 합니다. 찾고자 하는 패턴이 빈번한 경우에는 미리 컴파일해놓고 사용하면 속도와 편의성면에서 유리합니다.|
|re.search()|문자열 전체에 대해서 정규표현식과 매치되는지를 검색합니다.|
|re.match()|문자열의 처음이 정규표현식과 매치되는지를 검색합니다.|
|re.split()|정규 표현식을 기준으로 문자열을 분리하여 리스트로 리턴합니다.|
|re.fildall()|문자열에서 정규 표현식과 매치되는 모든 경우의 문자열을 찾아서 리스트로 리턴합니다. 만약, 매치되는 문자열이 없다면 빈 리스트가 리턴됩니다.|
|re.finditer()|문자열에서 정규 표현식과 매치되는 모든 경우의 문자열에 대한 이터레이터 객체를 리턴합니다.|
|re.sub()|문자열에서 정규 표현식과 일치하는 부분에 대해서 다른 문자열로대체합니다.|

앞으로 진행될 실습에서는 re.compile()에 정규 표현식을 컴파이랗고, re.search()를 통해서 해당 정규 표현식이 입력 텍스트와 매치되었는지를 확인하면서 각 정규 표현식에 대해서 이해해보겠습니다. re.search()는 매치된다면 Match Object를 리턴하고 매치되지 않으면 아무런 값도 출력되지 않습니다.

#### 2. 정규 표현식 실습

앞서 표로 봤던 정규 표현식을 예시를 통해 이해해보겠습니다.


```python
import re
```

##### (1) . 기호

.은 한 개의 임의의 문자를 나타냅니다. 예를 들어서 정규 표현식이 a.c라고 합시다. a와 c 사이에는 어떤 1개의 문자라도 올 수 있습니다. akc, azc, avc, a5c, a!c와 같은 형태는 모두 a.c의 정규 표현식과 매치됩니다.


```python
r = re.compile("a.c")
print(r.search("kkk"))
print(r.search("abc"))
```

    None
    <re.Match object; span=(0, 3), match='abc'>
    

.은 어떤 문자로도 인식될 수 있기 때문에 abc라는 문자열은 a.c라는 정규 표현식 패턴으로 매치됩니다.

##### (2) ? 기호

?는 ?앞에 문자가 존재할 수도 있고 존재하지 않을 수도 있는 경우를 나타냅니다. 예를 들어서 정규 표현식이 ab?c라고 합시다. 이 경우 이 정규 표현식에서의 b는 있다고 취합할 수도 있고, 없다고 취급할 수도 있습니다. 즉, abc와 ac 모두 매치할 수 있습니다.


```python
r = re.compile("ab?c")
print(r.search("abbc"))
print(r.search("abc"))
print(r.search("ac"))
```

    None
    <re.Match object; span=(0, 3), match='abc'>
    <re.Match object; span=(0, 2), match='ac'>
    

##### (3) * 기호

*은 바로 앞의 문자가 0개 이상일 경우를 나타냅니다. 앞의 문자는 존재하지 않을 수도 있으며, 또는 여러 개일 수도 있습니다. 정규 표현식이 ab*c라면 ac, abc, abbc, abbbc 등과 매치할 수 있으며 b의 개수는 무수히 많을 수 있습니다.


```python
r = re.compile("ab*c")
print(r.search("a"))
print(r.search("ac"))
print(r.search("abc"))
print(r.search("abbbbc"))
```

    None
    <re.Match object; span=(0, 2), match='ac'>
    <re.Match object; span=(0, 3), match='abc'>
    <re.Match object; span=(0, 6), match='abbbbc'>
    

##### (4) + 기호

+는 *와 유사합니다. 다른 점은 앞의 문자가 최소 1개 이상이어야 합니다. 정규 표현식이 ab+c라고 한다면 ac는 매치되지 않습니다. 하지만 abc, abbc, abbbc 등과 매치할 수 있으며 b의 개수는 무수히 많을 수 있습니다.


```python
r = re.compile("ab+c")
print(r.search("ac"))
print(r.search("abc"))
print(r.search("abbbbc"))
```

    None
    <re.Match object; span=(0, 3), match='abc'>
    <re.Match object; span=(0, 6), match='abbbbc'>
    

##### (5) ^ 기호

^는 시작되는 문자열을 지정합니다. 정규표현식이 ^ab라면 문자열 ab로 시작되는 경우 매치합니다.


```python
r = re.compile("^ab")

print(r.search("bbc"))
print(r.search("zab"))
print(r.search("abz"))
```

    None
    None
    <re.Match object; span=(0, 2), match='ab'>
    

##### (6) {숫자} 기호

문자에 해당 기호를 붙이면, 해당 문자를 숫자만큼 반복한 것을 나타냅니다. 예를 들어서 정규 표현식이 ab{2}c라면 a와 c사이에 b가 존재하면서 b가 2개인 문자열에 대해서 매치합니다.


```python
r = re.compile("ab{2}c")

print(r.search("ac"))
print(r.search("abc"))
print(r.search("abbbbbc"))
print(r.search("abbc"))
```

    None
    None
    None
    <re.Match object; span=(0, 4), match='abbc'>
    

##### (7) {숫자1,숫자2} 기호

문자에 해당 기호를 붙이면, 해당 문자를 숫자1 이상 숫자2 이하만큼 반복합니다. 예를 들어서 정규 표현식이 ab{2,8}c라면 a와 c사이에 b가 존재하면서 b는 2개 이상 8개 이하인 문자열에 대해서 매치합니다.


```python
# 주의할 점은 {2, 8}로 하면 안된다. 무조건 {2,8}으로 띄어쓰기를 쓰지말자!

r = re.compile("ab{2,8}c")

print(r.search("ac"))
print(r.search("abc"))
print(r.search("abbbbbbbbbbc"))
print(r.search("abbc"))
print(r.search("abbbbbbbbc"))
```

    None
    None
    None
    <re.Match object; span=(0, 4), match='abbc'>
    <re.Match object; span=(0, 10), match='abbbbbbbbc'>
    

##### (8) {숫자,} 기호

문자에 해당 기호를 붙이면 해당 문자를 숫자 이상 만큼 반복합니다. 예를 들어서 정규 표현식이 a{2,}bc라면 뒤에 bc가 붙으면서 a의 개수가 2개 이상인 경우의 문자열과 매치합니다. 또한 만약 {0,}을 쓴다면 *와 동일한 의미가 되며, {1,}을 쓴다면 +와 동일한 의미가 됩니다. 


```python
r = re.compile("a{2,}bc")

print(r.search("bc"))
print(r.search("aa"))
print(r.search("aabc"))
print(r.search("aaaaaaaaabc"))
```

    None
    None
    <re.Match object; span=(0, 4), match='aabc'>
    <re.Match object; span=(0, 11), match='aaaaaaaaabc'>
    

##### (9) [] 기호

[]안에 문자들을 넣으면 그 문자들 중 한 개의 문자와 매치라는 의미를 가집니다. 예를 들어서 정규 표현식이 [abc]라면, a 또는 b 또는 c가 들어가있는 문자열과 매치됩니다. 범위를 지정하는 것도 가능합니다. [a-zA-Z]는 알파벳 전부를 의미하며, [0-9]는 숫자 전부를 의미합니다.


```python
r = re.compile("[abc]")
print(r.search("zzz"))
print(r.search("a"))
print(r.search("aaaaaaaaa"))
print(r.search("baac"))
```

    None
    <re.Match object; span=(0, 1), match='a'>
    <re.Match object; span=(0, 1), match='a'>
    <re.Match object; span=(0, 1), match='b'>
    


```python
r = re.compile("[a-z]")

print(r.search("AAA"))
print(r.search("111"))
print(r.search("aBC"))
```

    None
    None
    <re.Match object; span=(0, 1), match='a'>
    

##### (10) [^문자] 기호

[^ 문자]는 ^ 기호 뒤에 붙은 문자들을 제외한 모든 문자를 매치하는 역할을 합니다. 예를 들어서 [^ abc]라는 정규 표현식이 있다면, a 또는 b 또는 c가 들어간 문자열을 제외한 모든 문자열을 매치합니다.


```python
r = re.compile("[^ abc]")
print(r.search("a"))
print(r.search("ab"))
print(r.search("b"))
print(r.search("d"))
print(r.search("1"))
```

    None
    None
    None
    <re.Match object; span=(0, 1), match='d'>
    <re.Match object; span=(0, 1), match='1'>
    

#### 3. 정규 표현식 모듈 함수 예제

앞서 re.compile()과 re.search()를 사용해보았습니다. 다른 정규 표현식 모듈 함수에 대해서 실습을 진행해보겠습니다.

##### (1) re.match() 와 re.search()의 차이

search()가 정규 표현식 전체에 대해서 문자열이 매치하는지를 본다면, match()는 무낮열의 첫 부분부터 정규 표현식과 매치하는지를 확인합니다. 문자열의 중간에 찾을 패턴이 있더라도 match 함수는 문자열의 시작에서 패턴이 일치하지 않으면 찾지 않습니다.


```python
r = re.compile("ab.")
print(r.match("kkkabc"))
print(r.search("kkkabc"))
print(r.search("abckkk"))
```

    None
    <re.Match object; span=(3, 6), match='abc'>
    <re.Match object; span=(0, 3), match='abc'>
    

위 경우 정규 표현식이 ab. 이기 때문에, ab 다음에는 어떤 한 글자가 존재할 수 있다는 패턴을 의미합니다. search 모듈 함수에 kkkabc라는 문자열을 넣어 매치되는지 확인한다면 abc라는 문자열에서 매치되어 Match Object를 리턴합니다. 하지만 match 모듈 함수의 경우 앞 부분이 ab.와 매치되지 않기 때문에, 아무런 결과도 출력되지 않습니다. 하지만 반대로 abckkk로 매치를 시도해보면, 시작 부분에서 패턴과 매치되었기 때문에 정상적으로 Match Object를 리턴합니다.

##### (2) re.split()

split() 함수는 입력된 정규 표현식을 기준으로 문자열들을 분리하여 리스트로 리턴합니다. 토큰화에 유용하게 쓰일 수 있습니다. 공백을 기준으로 문자열 분리를 수행하고 결과로서 리스트를 리턴해봅시다.


```python
text = "사과 딸기 수박 메론 바나나"

re.split(" ", text)
```




    ['사과', '딸기', '수박', '메론', '바나나']



이와 유사하게 줄바꿈이나 다른 정규 표현식을 기준으로 텍스트를 분리할 수도 있습니다.


```python
text = """사과
딸기
수박
메론
바나나"""

re.split("\n", text)
```




    ['사과', '딸기', '수박', '메론', '바나나']



##### (3) re.findall()

findall() 함수는 정규 표현식과 매치되는 모든 문자열들을 리스트로 리턴합니다. 단, 매치되는 문자열이 없다면 빈 리스트를 리턴합니다. 임의의 텍스트에 정규 표현식으로 숫자를 의미하는 규칙으로 findall()을 수행하면 전체 텍스트로부터 숫자만 찾아내서 리스트로 리턴합니다.


```python
text = """이름 : 김철수
전화번호 : 010 - 1234 - 1234
나이 : 30
성별 : 남"""

re.findall("\d+", text)
```




    ['010', '1234', '1234', '30']



하지만 만약 입력 텍스트에 숫자가 없다면 빈 리스트를 리턴하게 됩니다.


```python
re.findall("\d+", "문자열입니다.")
```




    []



##### (4) re.sub()

sub() 함수는 정규 표현식 패턴과 일치하는 문자열을 찾아 다른 문자열로 대체할 수 있습니다. 아래와 같은 정제 작업에 많이 사용되는데, 영어 문장에 각주 등과 같은 이유로 특수 문자가 섞여있는 경우에는 특수 문자를 제거하고 싶다면 알파벳 외의 문자는 공백으로 처리하는 등의 용도로 쓸 수 있습니다.


```python
text = "Regular expression : A regular expression, regex or regexp[1] (somtimes called a rational expression)[2][3] is, in theoretical computer science and formal language theory, a sequence of characters that define a search pattern."

preprocessed_text = re.sub('[^ a-zA-Z]', ' ', text)
print(preprocessed_text)
```

    Regular expression   A regular expression  regex or regexp     somtimes called a rational expression        is  in theoretical computer science and formal language theory  a sequence of characters that define a search pattern 
    

#### 4. 정규 표현식 텍스트 전처리 예제

다음과 같은 임의의 텍스트가 있다고 해봅시다. 테이블 형식의 데이터를 텍스트에 저장하였습니다.




```python
text = """100 John   PROF
101 James    STUD
102 Mac   STUD"""
```

'\s+'는 공백을 찾아내는 정규 표현식입니다. 뒤에 붙는 +는 최소 1개 이상의 패턴을 찾아낸다는 의미입니다. s는 공백을 의미하기 때문에 최소 1개 이상의 공백인 패턴을 찾아냅니다. split은 주어진 정규 표현식을 기준으로 분리하므로 결과는 아래와 같습니다.


```python
re.split('\s+', text)
```




    ['100', 'John', 'PROF', '101', 'James', 'STUD', '102', 'Mac', 'STUD']



공백을 기준으로 값이 구분되었습니다. 해당 입력으로부터 숫자만을 뽑아온다고 해봅시다. 여기서 \d는 숫자에 해당되는 정규 표현식입니다. +를 붙이면 최소 1개 이상의 숫자에 해당하는 값을 의미합니다. findall()은 해당 표현식에 일치하는 값을 찾아냅니다.


```python
re.findall('\d+', text)
```




    ['100', '101', '102']



이번에는 텍스트로부터 대문자인 행의 값만 가져와봅시다. 이 경우 정규 표현식에 대문자를 기준으로 매치시키면 됩니니다. 하지만 정규 표현식에 대문자라는 기준만을 넣을 경우에는 문자열을 가져오는 것이 아니라 모든 대문자 각각을 갖고 오게 됩니다.


```python
re.findall('[A-Z]', text)
```




    ['J', 'P', 'R', 'O', 'F', 'J', 'S', 'T', 'U', 'D', 'M', 'S', 'T', 'U', 'D']



대문자가 연속적으로 네번 등장하는 경우라는 조건을 추가해봅시다.


```python
re.findall('[A-Z]{4}', text)
```




    ['PROF', 'STUD', 'STUD']



대문자로 구성된 문자열들을 가져옵니다. 이름의 경우에는 대문자와 소문자가 섞여있는 상황입니다. 이름에 대한 행의 값을 갖고오고 싶다면 처음에 대문자가 등장한 후에 소문자가 여러번 등장하는 경우에 매치하게 됩니다.


```python
re.findall('[A-Z][a-z]+', text)
```




    ['John', 'James', 'Mac']



#### 5. 정규 표현식을 이용한 토큰화

NLTK에서는 정규 표현식을 사용해서 단어 토큰화를 수행하는 RegexpTokenizer를 지원합니다. RegexpTokenizer()에서 괄호 안에 하나의 토큰으로 규정하기를 원하는 정규 표현식을 넣어서 토큰화를 수행합니다.


```python
from nltk.tokenize import RegexpTokenizer

text = "Don't be fooled by the dark sounding name, Mr. Jone's Orphanage is as cheery as cheery goes for a pastry shop"

tokenizer1 = RegexpTokenizer('[\w]+')
tokenizer2 = RegexpTokenizer('\s+', gaps = True)

print(tokenizer1.tokenize(text))
print(tokenizer2.tokenize(text))
```

    ['Don', 't', 'be', 'fooled', 'by', 'the', 'dark', 'sounding', 'name', 'Mr', 'Jone', 's', 'Orphanage', 'is', 'as', 'cheery', 'as', 'cheery', 'goes', 'for', 'a', 'pastry', 'shop']
    ["Don't", 'be', 'fooled', 'by', 'the', 'dark', 'sounding', 'name,', 'Mr.', "Jone's", 'Orphanage', 'is', 'as', 'cheery', 'as', 'cheery', 'goes', 'for', 'a', 'pastry', 'shop']
    

tokenizer1에 사용한 \w+는 문자 또는 숫자가 1개 이상인 경우를 의미합니다. tokenizer2에서는 공백을 기준으로 토큰화하도록 했습니다. gaps = True는 해당 정규 표현식을 토큰으로 나누기 위한 기준으로 사용한다는 의미입니다. 만약 gaps = True라는 부분을 기재하지 않는다면, 토큰화의 결과는 공백들만 나오게 됩니다. tokenizer2의 결과는 위의 tokenizer1의 결과와는 달리 아포스트로피나 온점을 제외하지 않고 토큰화가 수행된 것을 확인할 수 있습니다.

### 6) 정수 인코딩(Integer Encoding)

컴퓨터는 텍스트보다는 숫자를 더 잘 처리 할 수 있습니다. 이를 위해 자연어 처리에서는 텍스트를 숫자로 바꾸는 여러가지 기법들일 있습니다. 그리고 그러한 기법들을 본격적으로 적용시키기 위한 첫 단계로 각 단어를 고유한 정수에 맵핑(mapping) 시키는 전처리 작업이 필요할 때가 있습니다.

예를 들어 갖고 있는 텍스트에 단어가 5000개가 있다면, 5000개의 단어들 각각에 1번부터 5000번까지 단어와 맵핑되는 고유한 정수. 다른 표현으로는 인덱스를 부여합니다. 가령 book은 150번, dog는 171번, love는 192번, books는 212번과 같이 숫자가 부여됩니다. 인덱스를 부여하는 방법은 여러 가지가 있을 수 있는데 랜덤으로 부여하기도 하지만, 보통은 단어 등장 빈도수를 기준으로 정렬한 뒤에 부여합니다.

#### 1. 정수 인코딩(Integer Encoding)

왜 이러한 작업이 필요한 지에 대해서는 뒤에서 원-핫 인코딩 실습이나, 워드 임베딩 챕터 등에서 알아보기로 하고 여기서는 어떤 과정으로 단어에 정수 인덱스를 부여하는지에 대해서만 정리하겠습니다.

단어에 정수를 부여하는 방법 중 하나로 단어를 빈도수 순으로 정렬한 단어 집합을 만들고, 빈도수가 높은 순서대로 차례로 낮은 숫자부터 정수를 부여하는 방법이 있습니다. 이해를 돕기위해 단어의 빈도수가 적당하게 분포되도록 의도적으로만든 텍스트 데이터를 가지고 실습해보겠습니다.

##### (1) dictionary 사용하기



```python
from nltk.tokenize import sent_tokenize
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
```


```python
raw_text = "A barber is a person. a barber is good person. a barber is huge person. he Knew A Secret! The Secret He Kept is huge secret. Huge secret. His barber kept his word. a barber kept his word. His barber kept his secret. But keeping and keeping such a huge secret to himself was driving the barber crazy. the barber went up a huge mountain."
```

우선 여러 문장이 함께 있는 텍스트 데이터로부터 문장 토큰화를 수행해보겠습니다.


```python
sentences = sent_tokenize(raw_text)
print(sentences)
```

    ['A barber is a person.', 'a barber is good person.', 'a barber is huge person.', 'he Knew A Secret!', 'The Secret He Kept is huge secret.', 'Huge secret.', 'His barber kept his word.', 'a barber kept his word.', 'His barber kept his secret.', 'But keeping and keeping such a huge secret to himself was driving the barber crazy.', 'the barber went up a huge mountain.']
    

기존의 텍스트 데이터가 문장 단위로 토큰화 된 것을 확인할 수 있습니다. 이제 정제 작업과 정규화 작업을 병행하며, 단어 토큰화를 수행합니다. 여기서는 단어들을 소문자화하여 단어의 개수를 통일시키고, 불용어와 단어 길이가 2이하인 경우에 대해서 단어를 일부 제외시켜주었습니다. 텍스트를 수치화하는 단계라는 것은 본격적으로 자연어 처리 작업에 들어간다는 의미이므로, 단어가 텍스트일 때만 할 수 있는 최대한의 전처리를 끝내놓아야합니다.


```python
vocab = {}
preprocessed_sentences = []
stop_words = set(stopwords.words("english"))

for sentence in sentences:
    # 단어 토큰화
    tokenized_sentence = word_tokenize(sentence)
    result = []
    for word in tokenized_sentence:
        word = word.lower() # 모든 단어를 소문자화하여 단어의 개수를 줄인다.
        
        if word not in stop_words: # 단어 토큰화 된 결과에 대해서 불용어를 제거한다.
            if len(word) > 2:
                result.append(word) # 단어 길이가 2 이하인 경우에 대해서 추가로 제거한다.
                
                if word not in vocab:
                    vocab[word] = 0
                vocab[word] += 1
    preprocessed_sentences.append(result)
print(preprocessed_sentences)
```

    [['barber', 'person'], ['barber', 'good', 'person'], ['barber', 'huge', 'person'], ['knew', 'secret'], ['secret', 'kept', 'huge', 'secret'], ['huge', 'secret'], ['barber', 'kept', 'word'], ['barber', 'kept', 'word'], ['barber', 'kept', 'secret'], ['keeping', 'keeping', 'huge', 'secret', 'driving', 'barber', 'crazy'], ['barber', 'went', 'huge', 'mountain']]
    

현재 vocab에는 각 단어에 대한 빈도수가 기록되어져 있습니다.


```python
print('단어 집합 : ', vocab)
```

    단어 집합 :  {'barber': 8, 'person': 3, 'good': 1, 'huge': 5, 'knew': 1, 'secret': 6, 'kept': 4, 'word': 2, 'keeping': 2, 'driving': 1, 'crazy': 1, 'went': 1, 'mountain': 1}
    

파이썬 딕셔너리 구조로 단어를 키로, 단어에 대한 빈도수가 값으로 저장되어져 있습니다. 이제 빈도수가 높은 순서대로 정렬해보겠습니다.


```python
vocab_sorted = sorted(vocab.items(), key = lambda x : x[1], reverse = True)
print(vocab_sorted)
```

    [('barber', 8), ('secret', 6), ('huge', 5), ('kept', 4), ('person', 3), ('word', 2), ('keeping', 2), ('good', 1), ('knew', 1), ('driving', 1), ('crazy', 1), ('went', 1), ('mountain', 1)]
    

높은 빈도수를 가진 단어일수록 낮은 정수를 부여해보겠습니다. 정수는 1부터 부여합니다.


```python
word_to_index = {}
i = 0
for (word, frequency) in vocab_sorted:
    if frequency > 1: # 빈도수가 작은 단어는 제외
        i += 1
        word_to_index[word] = i
        
print(word_to_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5, 'word': 6, 'keeping': 7}
    

1의 인덱스를 가진 단어가 가장 빈도수가 높은 단어가 됩니다. 그리고 이러한 작업을 수행하는 동시에 각 단어의 빈도수를 알 경우에만 할 수 있는 전처리인 빈도수가 적은 단어를 제외시키는 작업을 수행했습니다. 등장 빈도가 낮은 단어는 자연어 처리에서 의미를 가지지 않을 가능성이 높기 때문입니다. 여기서는 빈도수가 1인 단어들은 전부 제외시켰습니다. 

자연어 처리를 하다보면, 텍스트 데이터에 있는 단어를 모두 사용하기 보다는 빈도수가 가장 높은 n개의 단어만 사용하고 싶은 경우가 많습니다. 위 단어들은 빈도수가 높은 순으로 낮은 정수가 부여되어져 있으므로 빈도수 상위 n개의 단어만 사용하고 싶다고하면 vocab에서 정수값이 1부터 n까지인 단어들만 사용하면 됩니다. 여기서는 상위 5개 단어만 사용한다고 가정하겠습니다.


```python
vocab_size = 5

# 인덱스가 5 초과인 단어 제거
words_frequncy = [word for word, index in word_to_index.items() if index >= vocab_size + 1]

# 해당 단어에 대한 인덱스 정보를 삭제
for w in words_frequncy:
    del word_to_index[w]
print(word_to_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5}
    

word_to_index에는 빈도수가 높은 상위 5개의 단어만 저장되었습니다. word_to_index를 사용하여 단어 토큰화가 된 상태로 저장된 sentences에 있는 각 단어를 정수로 바꾸는 작업을 하겠습니다.

예를 들어 sentences에서 첫번째 문장은 ['barber', 'person']이었는데, 이 문장에 대해서는 [1, 5]로 인코딩합니다. 그런데 두번째 문장인 ['barber', 'good', 'person']에는 더 이상 word_to_index에는 존재하지 않는 단어인 'good'이라는 단어가 있습니다.

이처럼 단어 집합에 존재하지 않느 단어들이 생기는 상황을 Out-Of-Vocabulary(단어 집합에 없는 단어) 문제라고 합니다. 약자로 'OOV 문제'라고도 합니다. word_to_index에 'OOV'란 단어를 새롭게 추가하고, 단어 집합에 없는 단어들은 'OOV'의 인덱스로 인코딩하겠습니다.




```python
word_to_index['OOV'] = len(word_to_index) + 1
print(word_to_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5, 'OOV': 6}
    

이제 word_to_index를 사용하여 sentences의 모든 단어들을 맵핑되는 정수로 인코딩하겠습니다.


```python
encoded_sentences = []

for sentence in preprocessed_sentences:
    encoded_sentence = []
    for word in sentence:
        try:
            # 단어 집합에 있는 단어라면 해당 단어의 정수를 리턴
            encoded_sentence.append(word_to_index[word])
        except KeyError:
            # 만약 단어 집합에 없는 단어라면 'OOV'의 정수를 리턴
            encoded_sentence.append(word_to_index['OOV'])
    encoded_sentences.append(encoded_sentence)
print(encoded_sentences)
```

    [[1, 5], [1, 6, 5], [1, 3, 5], [6, 2], [2, 4, 3, 2], [3, 2], [1, 4, 6], [1, 4, 6], [1, 4, 2], [6, 6, 3, 2, 6, 1, 6], [1, 6, 3, 6]]
    

지금까지 파이썬의 dictionary 자료형으로 정수 인코딩을 진행해보았습니다. 그런데 이보다는 좀 더 쉽게 하기 위해서 Counter, FreqDist, enumerate를 사용하거나, 케라스 토크나이저를 사용하는 것을 권장합니다.

##### (2) Counter  사용하기


```python
from collections import Counter
```


```python
print(preprocessed_sentences)
```

    [['barber', 'person'], ['barber', 'good', 'person'], ['barber', 'huge', 'person'], ['knew', 'secret'], ['secret', 'kept', 'huge', 'secret'], ['huge', 'secret'], ['barber', 'kept', 'word'], ['barber', 'kept', 'word'], ['barber', 'kept', 'secret'], ['keeping', 'keeping', 'huge', 'secret', 'driving', 'barber', 'crazy'], ['barber', 'went', 'huge', 'mountain']]
    

현재 sentences는 단어 토큰화가 된 결과가 저장되어져 있습니다. 단어 집합을 만들기 위해서 sentences에서 문장의 결계인 []를 제거하고 단어 들을 하나의 리스트로 만들겠습니다.


```python
all_words_list = sum(preprocessed_sentences, [])
print(all_words_list)
```

    ['barber', 'person', 'barber', 'good', 'person', 'barber', 'huge', 'person', 'knew', 'secret', 'secret', 'kept', 'huge', 'secret', 'huge', 'secret', 'barber', 'kept', 'word', 'barber', 'kept', 'word', 'barber', 'kept', 'secret', 'keeping', 'keeping', 'huge', 'secret', 'driving', 'barber', 'crazy', 'barber', 'went', 'huge', 'mountain']
    

이를 파이썬의 Counter()의 입력으로 사용하면 중복을 제거하고 단어의 빈도수를 기록합니다.


```python
vocab = Counter(all_words_list)
print(vocab)
```

    Counter({'barber': 8, 'secret': 6, 'huge': 5, 'kept': 4, 'person': 3, 'word': 2, 'keeping': 2, 'good': 1, 'knew': 1, 'driving': 1, 'crazy': 1, 'went': 1, 'mountain': 1})
    

단어를 키로, 단어에 대한 빈도수가 값으로 저장되어져 있습니다. vocab에 단어를 입력하면 빈도수를 리턴합니다.


```python
print(vocab['barber'])
```

    8
    

barber란 단어가 총 8번 등장하였습니다. most_common()는 상위 빈도수를 가진 주어진 수의 단어만을 리턴합니다. 이를 사용하여 등장 빈도수가 높은 단어들을 원하는 개수만큼만 얻을 수 있습니다. 등장 빈도수 상위 5개의 단어만 단어 집합으로 저장해봅시다.


```python
vocab_size = 5
vocab = vocab.most_common(vocab_size)
print(vocab)
```

    [('barber', 8), ('secret', 6), ('huge', 5), ('kept', 4), ('person', 3)]
    

이제 높은 빈도수를 가진 단어일수록 낮은 정수 인덱스를 부여합니다.


```python
word_to_index = {}
i = 0
for (word, frequency) in vocab:
    i += 1
    word_to_index[word] = i
    
print(word_to_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5}
    

##### (3) NLTK의 FreqDist 사용하기

NLTK에서는 빈도수 계산 도구인 FreqDist()를 지원합니다. 위에서 사용한 Counter()랑 같은 방법으로 사용할 수 있습니다.


```python
from nltk import FreqDist
import numpy as np
```


```python
# np.hstack으로 문장 구분을 제거
vocab = FreqDist(np.hstack(preprocessed_sentences))
```

단어를 키로, 단어에 대한 빈도수가 값으로 저장되어져 있습니다. vocab에 단어를 입력하면 빈도수를 리턴합니다.


```python
print(vocab['barber'])
```

    8
    

barber란 단어가 총 8번 등장하였습니다. most_common()는 상위 빈도수를 가진 주어진 수의 단어만을 리턴합니다. 이를 사용하여 등장 빈도수가 높은 단어들을 원하는 개수만큼만 얻을 수 있습니다.


```python
vocab_size = 5
vocab = vocab.most_common(vocab_size)
print(vocab)
```

    [('barber', 8), ('secret', 6), ('huge', 5), ('kept', 4), ('person', 3)]
    

앞서 Counter()를 사용했을 때와 결과가 같습니다. 이전 실습들과 마찬가지로 높은 빈도수를 가진 단어일수록 낮은 정수 인덱스를 부여합니다. 그런데 이번에는 enumerate()를 사용하여 좀 더 짧은 코드로 인덱스를 부여하겠습니다.


```python
word_to_index = {word[0] : index + 1 for index, word in enumerate(vocab)}
print(word_to_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5}
    

위와 같이 인덱스를 부여할 때는 enumerate()를 사용하는 것이 편리합니다. enumerate()에 대해서 간단히 소개해보겠습니다.

##### (4) enumerate 이해하기

enumerate()는 순서가 있는 자료형(list, set, tuple, dictionary, string)을 입력으로 받아 인덱스를 순차적으로 함께 리턴하는 특징이 있습니다.


```python
test_input = ['a', 'b', 'c', 'd', 'e']
for index, value in enumerate(test_input):
    print('value : {}, index : {}'.format(value, index))
```

    value : a, index : 0
    value : b, index : 1
    value : c, index : 2
    value : d, index : 3
    value : e, index : 4
    

위의 출력 결과는 리스트의 모든 토큰에 대해서 인덱스가 순차적으로 증가되며 부여된 것을 보여줍니다.

#### 2. 케라스(Keras)의 텍스트 전처리

케라스는 기본적인 전처리를 위한 도구들을 제공합니다. 때로는, 정수 인코딩을 위해서 케라스의 전처리 도구인 토크나이저를 사용하기도 하는데, 사용 방법과 그 특징에 대해서 이해해보겠습니다.


```python
from tensorflow.keras.preprocessing.text import Tokenizer
```


```python
preprocessed_sentences = [['barber', 'person'], ['barber', 'good', 'person'], ['barber', 'huge', 'person'], ['knew', 'secret'], ['secret', 'kept', 'huge', 'secret'], ['huge', 'secret'], ['barber', 'kept', 'word'], ['barber', 'kept', 'word'], ['barber', 'kept', 'secret'], ['keeping', 'keeping', 'huge', 'secret', 'driving', 'barber', 'crazy'], ['barber', 'went', 'huge', 'mountain']]
```

단어 토큰화까지 수행된 앞서 사용한 텍스트 데이터와 동일한 데이터를 사용합니다.


```python
tokenizer = Tokenizer()

# fit_on_texts()안에 코퍼스를 입력으로 하면 빈도수를 기준으로 단어 집합이 생성됩니다.
tokenizer.fit_on_texts(preprocessed_sentences)
```

fit_on_texts는 입력한 텍스트로부터 단어 빈도수가 높은 순으로 낮은 정수 인덱스를 부여하는데, 정확히 앞서 설명한 정수 인코딩 작업이 이루어진다고 보면됩니다. 각 단어에 인덱스가 어떻게 부여되었는지 보려면, word_index를 사용합니다.


```python
print(tokenizer.word_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5, 'word': 6, 'keeping': 7, 'good': 8, 'knew': 9, 'driving': 10, 'crazy': 11, 'went': 12, 'mountain': 13}
    

각 단어의 빈도수가 높은 순서대로 인덱스가 부여된 것을 확인할 수 있습니다. 각 단어가 카운트를 수행하였을 때, 몇 개였는지를 보고자 한다면 word_counts를 사용합니다.


```python
print(tokenizer.word_counts)
```

    OrderedDict([('barber', 8), ('person', 3), ('good', 1), ('huge', 5), ('knew', 1), ('secret', 6), ('kept', 4), ('word', 2), ('keeping', 2), ('driving', 1), ('crazy', 1), ('went', 1), ('mountain', 1)])
    

texts_to_sentences()는 입력으로 들어온 코퍼스에 대해서 각 단어를 이미 정해진 인덱스로 변환합니다.


```python
print(tokenizer.texts_to_sequences(preprocessed_sentences))
```

    [[1, 5], [1, 8, 5], [1, 3, 5], [9, 2], [2, 4, 3, 2], [3, 2], [1, 4, 6], [1, 4, 6], [1, 4, 2], [7, 7, 3, 2, 10, 1, 11], [1, 12, 3, 13]]
    

앞서 빈도수가 가장 높은 단어 n개만 사용하기 위해서 most_common()을 사용했었습니다. 케라스 토크나이저에서는 tokenizer = Tokenzier(num_words = 숫자)와 같은 방법으로 빈도수가 높은 상위 몇 개의 단어만 사용하겠다고 지정할 수 있습니다. 여기서는 1번 단어부터 5번 단어까지만 사용하겠습니다. 상위 5개 단어를 사용한다고 토크나이저를 재정의 해보겠습니다.


```python
vocab_size = 5
tokenizer = Tokenizer(num_words = vocab_size + 1)
tokenizer.fit_on_texts(preprocessed_sentences)
```

num_words에서 +1을 더해서 값을 넣어주는 이유는 num_words는 숫자를 0부터 카운트합니다. 만약 5를 넣으면 0 ~ 4번 단어 보존을 의미하게 되므로 뒤의 실습에서 1번 단어부터 4번 단어만 남게됩니다. 그렇기 때문에 1 ~ 5번 단어까지 사용하고 싶다면 num_words에 숫자 5를 넣어주는 것이 아니라 5+1인 값을 넣어주어야 합니다.

실질적으로 숫자 0에 지정된 단어가 존재하지 않는데도 케라스 토크나이저가 숫자 0까지 단어 집합의 크기로 산정하는 이유는 자연어 처리에서 패딩(paddind)이라는 작업 때문입니다. 이에 대해서는 뒤에 다루게 되므로 여기서는 케라스 토크나이저를 사용할 때는 숫자 0도 단어 집합의 크기로 고려해야한다고만 이해합시다.


```python
print(tokenizer.word_index)
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5, 'word': 6, 'keeping': 7, 'good': 8, 'knew': 9, 'driving': 10, 'crazy': 11, 'went': 12, 'mountain': 13}
    

상위 5개의 단어만 사용하겠다고 선언하였는데 여전히 13개의 단어가 모두 출력됩니다. word_counts를 확인해보겠습니다.


```python
print(tokenizer.word_counts)
```

    OrderedDict([('barber', 8), ('person', 3), ('good', 1), ('huge', 5), ('knew', 1), ('secret', 6), ('kept', 4), ('word', 2), ('keeping', 2), ('driving', 1), ('crazy', 1), ('went', 1), ('mountain', 1)])
    

word_counts에서도 마찬가지로 13개의 단어가 모두 출력됩니다. 사실 실제 적용은 texts_to_sequences를 사용할 때 적용이 됩니다.


```python
print(tokenizer.texts_to_sequences(preprocessed_sentences))
```

    [[1, 5], [1, 5], [1, 3, 5], [2], [2, 4, 3, 2], [3, 2], [1, 4], [1, 4], [1, 4, 2], [3, 2, 1], [1, 3]]
    

코퍼스에 대해서 각 단어를 이미 정해진 인덱스로 변환하는데, 상위 5개의 단어만을 사용하겠다고 지정하였으므로 1번 단어부터 5번 단어까지만 보존되고 나머지 단어들은 제거된 것을 볼 수 있습니다. 경험상 굳이 필요하다고 생각하지는 않지만, 만약 word_index와 word_counts에서도 지정된 num_words만큼의 단어만 남기고 싶다면 아래의 코드도 방법입니다.


```python
tokenizer = Tokenizer()
tokenizer.fit_on_texts(preprocessed_sentences)
```


```python
vocab_size = 5
words_frequency = [word for word, index in tokenizer.word_index.items() if index >= vocab_size + 1]

# 인덱스가 5 초과인 단어 제거
for word in words_frequency:
    del tokenizer.word_index[word] # 해당 단어에 대한 인덱스 정보를 삭제
    del tokenizer.word_counts[word] # 해당 단어에 대한 카운트 정보를 삭제
        
print(tokenizer.word_index)
print(tokenizer.word_counts)
print(tokenizer.texts_to_sequences(preprocessed_sentences))
```

    {'barber': 1, 'secret': 2, 'huge': 3, 'kept': 4, 'person': 5}
    OrderedDict([('barber', 8), ('person', 3), ('huge', 5), ('secret', 6), ('kept', 4)])
    [[1, 5], [1, 5], [1, 3, 5], [2], [2, 4, 3, 2], [3, 2], [1, 4], [1, 4], [1, 4, 2], [3, 2, 1], [1, 3]]
    

케라스 토크나이저는 기본적으로 단어 집합에 없는 단어인 OOV에 대해서는 단어를 정술 ㅗ바꾸는 과정에서 아예 단어를 제거한다는 특징이 있습니다. 단어 집합에 없는 단어들은 OOV로 간주하여 보존하고 싶다면 Tokenizer의 인자 oov_token을 사용합니다.


```python
# 숫자 0과 OOV를 고려해서 단어 집합의 크기는 +2

vocab_size = 5
tokenizer = Tokenizer(num_words = vocab_size + 2, oov_token = 'OOV')
tokenizer.fit_on_texts(preprocessed_sentences)
```

만약 oov_token을 사용하기로 했다면 케라스 토큰나이저는 기본적으로 'OOV'의 인덱스를 1로 합니다.


```python
print('단어 OOV의 인덱스 : {}'.format(tokenizer.word_index['OOV']))
```

    단어 OOV의 인덱스 : 1
    

이제 코퍼스에 대해서 정수 인코딩을 진행합니다.


```python
print(tokenizer.texts_to_sequences(preprocessed_sentences))
```

    [[2, 6], [2, 1, 6], [2, 4, 6], [1, 3], [3, 5, 4, 3], [4, 3], [2, 5, 1], [2, 5, 1], [2, 5, 3], [1, 1, 4, 3, 1, 2, 1], [2, 1, 4, 1]]
    

빈도수 상위 5개의 단어는 2~6까지의 인덱스를 가졌으며, 그 외 단어 집합에 없는 'good'과 같은 단어들은 전부 'OOV'의 인덱스인 1로 인코딩 되었습니다.

### 7) 패딩(Paddind)

자연어 처리를 하다보면 각 문장(또는 문서)은 서로 길이가 다를 수 있습니다. 그런데 기계는 길이가 전부 동일한 문서들에 대해서는 하나의 행렬로 보고, 한꺼번에 묶어서 처리할 수 있습니다. 다시 말해 병렬 연산을 위해서 여러 문장의 길이를 임의로 동일하게 맞춰주는 작업이 필요할 때가 있습니다. 실습을 통해 이해해 봅시다.

#### 1. Numpy로 패딩하기


```python
import numpy as np
from tensorflow.keras.preprocessing.text import Tokenizer
```

정수 인코딩 챕터에서 수행했던 실습을 그대로 반복해보겠습니다. 아래와 같이 텍스트 데이터가 있습니다.


```python
preprocessed_sentences = [['barber', 'person'], ['barber', 'good', 'person'], ['barber', 'huge', 'person'], ['knew', 'secret'], ['secret', 'kept', 'huge', 'secret'], ['huge', 'secret'], ['barber', 'kept', 'word'], ['barber', 'kept', 'word'], ['barber', 'kept', 'secret'], ['keeping', 'keeping', 'huge', 'secret', 'driving', 'barber', 'crazy'], ['barber', 'went', 'huge', 'mountain']]
```

단어 집합을 만들고, 정수 인코딩을 수행합니다.


```python
tokenizer = Tokenizer()
tokenizer.fit_on_texts(preprocessed_sentences)
encoded = tokenizer.texts_to_sequences(preprocessed_sentences)
print(encoded)
```

    [[1, 5], [1, 8, 5], [1, 3, 5], [9, 2], [2, 4, 3, 2], [3, 2], [1, 4, 6], [1, 4, 6], [1, 4, 2], [7, 7, 3, 2, 10, 1, 11], [1, 12, 3, 13]]
    

모든 단어가 고유한 정수로 변환되었습니다. 모두 동일한 길이로 맞춰주기 위해서 이 중에서 가장 길이가 긴 문장의 길이를 계산해보겠습니다.


```python
max_len = max(len(item) for item in encoded)
print('최대 길이 : ', max_len)
```

    최대 길이 :  7
    

가장 길이가 긴 문장의 길이는 7입니다. 모든 문장의 길이를 7로 맞춰주겠습니다. 이때 가상의 단어 'PAD'를 사용합니다. 'PDA'라는 단어가 있다고 가정하고, 이 단어는 0번 단어라고 정의합니다. 길이가 7보다 짧은 문장에는 숫자 0을 채워서 길이 7로 맞춰줍니다.


```python
for sentence in encoded:
    while len(sentence) < max_len:
        sentence.append(0)
        
padded_np = np.array(encoded)
print(padded_np)
```

    [[ 1  5  0  0  0  0  0]
     [ 1  8  5  0  0  0  0]
     [ 1  3  5  0  0  0  0]
     [ 9  2  0  0  0  0  0]
     [ 2  4  3  2  0  0  0]
     [ 3  2  0  0  0  0  0]
     [ 1  4  6  0  0  0  0]
     [ 1  4  6  0  0  0  0]
     [ 1  4  2  0  0  0  0]
     [ 7  7  3  2 10  1 11]
     [ 1 12  3 13  0  0  0]]
    

길이가 7보다 짧은 문장에는 전부 숫자 0이 뒤로 붙어서 모든 문장의 길이가 전부 7이된 것을 알 수 있습니다. 기계는 이들을 하나의 행렬로 보고, 병렬 처리를 할 수 있습니다. 또한, 0번 단어는 사실 아무런 의미도 없는 단어이기 때문에 자연어 처리하는 과정에서 기계는 0번 단어를 무시하게 될 것입니다. 이와 같이 <u>데이터에 특정 값을 채워서 데이터의 크기를 조정하는 것</u>을 `패딩(paddind)`이라고 합니다. <u>숫자 0을 사용하고 있다면</u> `제로 패딩(zero paddind)`이라고 합니다.

#### 2. 케라스 전처리 도구로 패딩하기

케라스에서는 위와 같은 패딩을 위해 pad_sequences()를 제공하고 있습니다.


```python
from tensorflow.keras.preprocessing.sequence import pad_sequences
```

encoded 값이 위에서 이미 패딩 후의 결과로 저장되었기 때문에 패딩 이전의 값으로 다시 되돌리겠습니다.


```python
encoded = tokenizer.texts_to_sequences(preprocessed_sentences)
print(encoded)
```

    [[1, 5], [1, 8, 5], [1, 3, 5], [9, 2], [2, 4, 3, 2], [3, 2], [1, 4, 6], [1, 4, 6], [1, 4, 2], [7, 7, 3, 2, 10, 1, 11], [1, 12, 3, 13]]
    

케라스의 pad_sequences를 사용하여 패딩을 해봅시다.


```python
padded = pad_sequences(encoded)
print(padded)
```

    [[ 0  0  0  0  0  1  5]
     [ 0  0  0  0  1  8  5]
     [ 0  0  0  0  1  3  5]
     [ 0  0  0  0  0  9  2]
     [ 0  0  0  2  4  3  2]
     [ 0  0  0  0  0  3  2]
     [ 0  0  0  0  1  4  6]
     [ 0  0  0  0  1  4  6]
     [ 0  0  0  0  1  4  2]
     [ 7  7  3  2 10  1 11]
     [ 0  0  0  1 12  3 13]]
    

Numpy로 패딩을 진행하였을 때와는 패딩 결과가 다른데 그 이유는 pad_sequences는 기본적으로 문서의 뒤에 0을 채우는 것이 아니라 앞을 0으로 채우기 때문입니다. 뒤에 0을 채우고 싶다면 인자로 padding = 'post'를 주면 됩니다.


```python
padded = pad_sequences(encoded, padding = 'post')
print(padded)
```

    [[ 1  5  0  0  0  0  0]
     [ 1  8  5  0  0  0  0]
     [ 1  3  5  0  0  0  0]
     [ 9  2  0  0  0  0  0]
     [ 2  4  3  2  0  0  0]
     [ 3  2  0  0  0  0  0]
     [ 1  4  6  0  0  0  0]
     [ 1  4  6  0  0  0  0]
     [ 1  4  2  0  0  0  0]
     [ 7  7  3  2 10  1 11]
     [ 1 12  3 13  0  0  0]]
    

Numpy를 이용하여 패딩을 했을 때와 결과가 동일합니다. 실제로 결과가 동일한지 두 결과를 비교합니다.


```python
(padded == padded_np).all()
```




    True



True값이 리턴됩니다. 두 결과가 동일하다는 의미입니다. 지금까지는 가장 긴 길이를 가진 문서의 길이를 기준으로 패딩을 한다고 가정하였지만, 실제로는 꼭 가장 긴 문서의 길이를 기준을 ㅗ해야하는 것은 아닙니다. 가령, 모든 문서의 평균 길이가 20인데 문서 1개의 길이가 5000이라고 해서 굳이 모든 문서의 길이를 5000으로 패딩할 필요는 없을 수 있습니다. 이와 같은 경우에는 길이에 제한을 두고 패딩할 수 있습니다. maxlen의 인자로 정수를 주면, 해당 정수로 모든 문서의 길이를 동일하게 합니다.


```python
padded = pad_sequences(encoded, padding = 'post', maxlen = 5)
print(padded)
```

    [[ 1  5  0  0  0]
     [ 1  8  5  0  0]
     [ 1  3  5  0  0]
     [ 9  2  0  0  0]
     [ 2  4  3  2  0]
     [ 3  2  0  0  0]
     [ 1  4  6  0  0]
     [ 1  4  6  0  0]
     [ 1  4  2  0  0]
     [ 3  2 10  1 11]
     [ 1 12  3 13  0]]
    

길이가 5보다 짧은 문서들은 0으로 패딩되고, 기존이 5보다 길었다면 데이터가 손실됩니다. 가령, 뒤에서 두번째 문장은 본래 [7, 7, 3, 2, 10, 1, 11]였으나 현재는 [3, 2, 10, 1, 11]로 변경된 것을 볼 수 있습니다. 만약, 데이터가 손실될 경우 앞의 단어가 아니라 뒤의 단어가 삭제되도록 하고싶다면 truncating이라는 인자를 사용합니다. truncating = 'post'를 사용할 경우 뒤의 단어가 삭제됩니다.


```python
padded = pad_sequences(encoded, padding = 'post', truncating = 'post', maxlen = 5)
print(padded)
```

    [[ 1  5  0  0  0]
     [ 1  8  5  0  0]
     [ 1  3  5  0  0]
     [ 9  2  0  0  0]
     [ 2  4  3  2  0]
     [ 3  2  0  0  0]
     [ 1  4  6  0  0]
     [ 1  4  6  0  0]
     [ 1  4  2  0  0]
     [ 7  7  3  2 10]
     [ 1 12  3 13  0]]
    

숫자 0으로 패딩하는 것은 널리 퍼진 관례이긴 하지만, 반드시 지켜야하는 규칙은 아닙니다. 만약, 숫자 0이 아니라 다른 숫자를 패딩을 위한 숫자로 사용하고 싶다면 이 또한 가능합니다. 현재 사용된 정수들과 겹치지 않도록, 단어 집합의 크기에 +1을 한 숫자로 사용해봅시다.


```python
last_value = len(tokenizer.word_index) + 1 # 단어 집합의 크기보다 1 큰 숫자를 사용
print(last_value)
```

    14
    

현재 단어가 총 13개이고, 1번부터 13까지 정수가 사용되었으므로 단어 집합의 크기에 +1을 하면 마지막 숫자인 13보다 1이 큰 14를 얻습니다. pad_sequences의 인자로 value를 사용하면 0이 아닌 다른 숫자로 패딩이 가능합니다.


```python
padded = pad_sequences(encoded, padding = 'post', value = last_value)
print(padded)
```

    [[ 1  5 14 14 14 14 14]
     [ 1  8  5 14 14 14 14]
     [ 1  3  5 14 14 14 14]
     [ 9  2 14 14 14 14 14]
     [ 2  4  3  2 14 14 14]
     [ 3  2 14 14 14 14 14]
     [ 1  4  6 14 14 14 14]
     [ 1  4  6 14 14 14 14]
     [ 1  4  2 14 14 14 14]
     [ 7  7  3  2 10  1 11]
     [ 1 12  3 13 14 14 14]]
    

### 8) 원 - 핫 인코딩(One - Hot Encoding)

컴퓨터 또는 기계는 문자보다는 숫자를 더 잘 처리 할 수 있습니다. 이를 위해 자연어 처리에서는 문자를 숫자로 바꾸는 여러가지 기법들이 있습니다. 원-핫 인코딩은 그 많은 기법 중에서 단어를 표현하는 가장 기본적인 표현 방법이며, 머신 러닝, 딥 러닝을 하기 위해서는 반드시 배워야 하는 표현 방법입니다. 

원-핫 인코딩에 대해서 배우기에 앞서 `단어 집합(vocabulary)`에 대해서 정의해보겠습니다. 단어 집합은 앞으로 자연어 처리에서 계속 나오는 개념이기 때문에 여기서 이해하고 가셔야합니다. 단어 집합은 서로 다른 단어들의 집합입니다. 여기서 혼동이 없도록 서로 다른 단어라는 정의에 대해서 좀 더 주목할 필요가 있습니다. 단어 집합에서는 기본적으로 book과 books와 같이 단어의 변형 형태도 다른 단어로 간주합니다. 이 책에서는 앞으로 단어 집합에 있는 단어들을 가지고, 문자를 숫자. 더 구체적으로는 벡터로 바꾸는 원-핫 인코딩을 포함한 여러 방법에 대해서 배우게 됩니다.

원-핫 인코딩을 위해서는 먼저 해야할 일은 단어 집합을 만드는 일입니다. 텍스트의 모든 단어를 중복을 허용하지 않고 모아놓으면 이를 단어 집합이라고 합니다. 그리고 이 단어 집합에 고유한 정수를 부여하는 정수 인코딩을 진행합니다. 텍스트에 단어가 총 5000개가 존재한다면, 단어 집합의 크기는 5000입니다. 5000개의 단어가 있는 이 단어 집합의 단어들마다 1번부터 5000번까지 인덱스를 부여한다고 해보겠습니다. 가령, book은 150번, dog는 171번, love는 192번, books는 212번과 같이 부여할 수 있습니다.

이제 각 단어에 고유한 정수 인덱스를 부여하였다고 합시다. 그럼 이 숫자로 바뀐 단어들을 벡터로 다뤄보겠습니다.

#### 1. 원 - 핫 인코딩(One - Hot Encoding)이란?

원-핫 인코딩은 단어 집합의 크기를 벡터의 차원으로 하고, 표현하고 싶은 단어의 인덱스에 1의 값을 부여하고, 다른 인덱스에는 0을 부여하는 단어의 벡터 표현방식입니다. 이렇게 표현된 벡터를 원-핫 벡터(One - Hot vector)라고 합니다.

원-핫 인코딩을 두 가지 과정으로 정리해보겠습니다. 첫째, 정수 인코딩을 수행합니다. 다시 말해 각 단어에 고유한 정수를 부여합니다. 둘째, 표현하고 싶은 단어의 고유한 정수를 인덱스로 간주하고 해당 위치에 1을 부여하고, 다른 단어의 인덱스의 위치에는 0을 부여합니다. 한국어 문장을 예제로 원-핫 벡터를 만들어보겠습니다.

문장 : 나는 자연어 처리를 배운다.

Okt 형태소 분석기를 통해서 문장에 대해서 토큰화를 수행합니다.


```python
from konlpy.tag import Okt

okt = Okt()
tokens = okt.morphs('나는 자연어 처리를 배운다')
print(tokens)
```

    ['나', '는', '자연어', '처리', '를', '배운다']
    

각 토큰에 대해서 고유한 정수를 부여합니다. 지금은 문장이 짧기 때문에 각 단어의 빈도수를 고려하지 않지만, 빈도수 순으로 단어를 정렬하여 정수를 부여하는 경우가 많습니다.


```python
word_to_index = {word : index for index, word in enumerate(tokens)}
print('단어 집합 : ', word_to_index)
```

    단어 집합 :  {'나': 0, '는': 1, '자연어': 2, '처리': 3, '를': 4, '배운다': 5}
    

토큰을 입력하면 해당 토큰에 대한 원-핫 벡터를 만들어내는 함수를 만들었습니다. 


```python
def one_hot_encoding(word, word_to_index):
    one_hot_vector = [0] * (len(word_to_index))
    index = word_to_index[word]
    one_hot_vector[index] = 1
    return one_hot_vector
```

'자연어'라는 단어의 원-핫 벡터를 얻어봅시다.


```python
one_hot_encoding('자연어', word_to_index)
```




    [0, 0, 1, 0, 0, 0]



'자연어'는 정수 2이므로 원-핫 벡터는 인덱스 2의 값이 1이며, 나머지 값은 0인 벡터가 나옵니다.

#### 2. 케라스(Keras)를 이용한 원 - 핫 인코딩(One - Hot Encoding)

위에서는 원-핫 인코딩을 이해하기 위해 파이썬으로 직접 코드를 작성하였지만, 케라스는 원-핫 인코딩을 수행하는 유용한 도구 to_categorical()를 지원합니다. 이번에는 케라스만으로 정수 인코딩과 원-핫 인코딩을 순차적으로 진행해보도록 하겠습니다.


```python
text = '나랑 점심 먹으러 갈래 점심 메뉴는 햄버거 갈래 갈래 햄버거 최고야'
```

위와 같은 문장이 있다고 했을 때, 케라스 토크나이저를 이용한 정수 인코딩은 다음과 같습니다. 


```python
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.utils import to_categorical

tokenizer = Tokenizer()
tokenizer.fit_on_texts([text]) # 리스트로 감싸줘야한다!
print('단어 집합 : ', tokenizer.word_index)
```

    단어 집합 :  {'갈래': 1, '점심': 2, '햄버거': 3, '나랑': 4, '먹으러': 5, '메뉴는': 6, '최고야': 7}
    

위와 같이 생성된 단어 집합에 있는 단어들로만 구성된 텍스트가 있다면, texts_to_sequneces()를 통해서 이를 정수 시퀀스로 변환가능합니다. 생성된 단어 집합 내의 일부 단어들로만 구성된 서브 텍스트인 sub_text를 만들어 확인해 보겠습니다.


```python
sub_text = '점심 먹으러 갈래 메뉴는 햄버거 최고야'
encoded = tokenizer.texts_to_sequences([sub_text])[0] # 리스트로 감싸줘야한다!
print(encoded)
```

    [2, 5, 1, 6, 3, 7]
    

지금까지 진행한 것은 이미 이전에 정수 인코딩 실습을 하며 배운 내용입니다. 이제 해당 결과를 가지고, 원-핫 인코딩을 진행해보겠습니다. 케라스는 정수 인코딩된 결과로부터 원-핫 인코딩을 수행하는 to_categorical()를 지원합니다.


```python
one_hot = to_categorical(encoded)
print(one_hot)
```

    [[0. 0. 1. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 1. 0. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 1. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 1.]]
    

위의 결과는 '점심 먹으러 갈래 메뉴는 햄버거 최고야'라는 문장이 [2, 5, 1, 6, 3, 7]로 정수 인코딩이 되고나서, 각각의 인코딩 된 결과를 인덱스로 원-핫 인코딩이 수행된 모습을 보여줍니다.

#### 3. 원 - 핫 인코딩(One - Hot Encoding)의 한계

이러한 표현 방식은 단어의 개수가 늘어날 수록, 벡터를 저장하기 위해 필요한 공간이 계속 늘어난다는 단점이 있습니다. 다른 표현으로는 벡터의 차원이 늘어난다고 표현합니다. 원 핫 벡터는 단어 집합의 크기가 곧 벡터의 차원 수가 됩니다. 가령, 단어가 1000개인 코퍼스를 가지고 원 핫 벡터를 만들면, 모든 단어 각각은 모두 1000개의 차원을 가진 벡터가 됩니다. 다시 말해 모든 단어 각각은 하나의 값만 1을 가지고, 999개의 값은 0의 값을 가지는 벡터가 되는데 이는 저장 공간 축면에서는 매우 비효율적인 표현 방법입니다.

또한 원-핫 벡터는 단어의 유사도를 표현하지 못한다는 단점이 있습니다. 예를 들어서 늑대, 호랑이, 강아지, 고양이라는 4개의 단어에 대해서 원-핫 벡터를 부여받았다고 합시다. 이때 원-핫 벡터로는 강아지와 늑대가 유사하고, 호랑이와 고양이가 유사하다는 것을 표현할 수가 없습니다, 좀 더 극단적으로는 강아지, 개, 냉장고라는 단어가 있을 때 강아지라는 단어가 개와 냉장고라는 단어 중 어떤 단어와 더 유사한지도 알 수 없습니다.

단어 간 유사성을 알 수 없다는 단점은 검색 시스템 등에서는 문제가 될 소지가 있습니다. 가령, 여행을 가려고 웹 검색창에 '삿포로 숙소'라는 단어를 검색한다고 합시다. 제대로 된 검색 시스템이라면, '삿포로 숙소'라는 검색어에 대해서 '삿포로 게스트 하우스', '삿포로 료칸', '삿포로 호텔'과 같은 유사 단어에 대한 결과도 함께 보여줄 수 있어야 합니다. 하지만 단어간 유사성을 계산할 수 없다면, '게스트 하우스'와 '료칸'과 '호텔'이라는 연관 검색어를 보여줄 수 없습니다.

이러한 단점을 해결하기 위해 단어의 잠재 의미를 반영하여 다차원 공간에 벡터화 하는 기법으로 크게 두 가지가 있습니다. 첫째는 카운트 기반의 벡터화 방법인 `LSA(잠재 의미 분석)`, `HAL` 등이 있으며, 둘째는 예측 기반으로 벡터화하는 `NNLM`, `RNNLM`, `Word2Vec`, `FastText` 등이 있습니다. 그리고 카운트 기반과 예측 기반 두 가지 방법을 모두 사용하는 방법으로 GloVe라는 방법이 존재합니다.

여기서 언급한 방법들 중 대부분은 후에 다루게 됩니다.

### 9) 데이터의 분리(Splitting Data)

머신 러닝 모델을 학습시키고 평가하기 위해서는 데이터를 적절하게 분리하는 작업이 필요합니다. 이 책에서는 대부분의 경우에서 지도 학습(Supervised Learning)을 다루는데, 이번에는 지도 학습을 위한 데이터 분리 작업에 대해서 배웁니다. 


```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
```

#### 1. 지도 학습(Supervised Learning)

지도 학습을 쉽게 비유하면, 기계는 정답이 적혀져 있는 문제지를 문제와 정답을 함께 보면서 열심히 공부하고, 향후에 정답이 없는 문제에 대해서도 정답을 잘 예측해야 합니다.

예를 들어 스팸 메일 분류기를 위한 데이터 같은 경우에는 메일의 본문과 해당 메일이 정상 메일인지, 스팸 메일인지 적혀있는 레이블로 구성되어져 있습니다. 예를 들어 아래와 같은 형식의 데이터가 약 20000개 있다고 가정해보겠습니다. 첫번째 열과 해당 메일이 정상 메일인지 스팸 메일인지가 적혀있는 정답에 해당되는 두번째 열입니다. 그릭 ㅗ이러한 데이터 배열이 총 20000개의 행을 가집니다.

|**텍스트(메일의 내용)**|**레이블(스팸 여부)**|
|:---|:---|
|당신에게 드리는 마지막 혜택! ...|스팸 메일|
|내일 뵐 수 있을지 확인 부탁...|정상 메일|
|...|...|
|(광고) 멋있어질 수 있는...|스팸 메일|

기계를 지도하는 선생님의 입장이 되어보겠습니다. 기계를 훈련시키기 위해서 데이터를 총 4개로 나눕니다. 우선 메일의 내용이 담긴 첫번째 열을 X에 저장합니다. 그리고 메일이 스팸인지 정상인지 정답이 적혀있는 두번째 열을 y에 저장합니다. 이제 문제지에 해당되는 20000개의 X와 정답지에 해당되는 20000개의 y가 생겼습니다.

그리고 이제 이 X와 y에 대해서 일부 데이터를 또 다시 분리합니다. 이는 문제지를 다 공부하고나서 실력을 평가하기 위해서 시험용으로 일부로 일부 문제와 해당 문제의 정답지를 분리해놓은 것입니다. 여기서는 2000개를 분리한다고 가정하겠습니다. 이때 분리 시에는 여전히 X(문제)와 y(정답)의 맵핑 관계를 유지해야 합니다. 어떤 X에 대한 어떤 y인지 바로 찾ㅅ을 수 있어야 합니다. 이렇게 되면 학습용에 해당되는 18000개의 X, y의 쌍과 시험용에 해당되는 2000개의 X, y의 쌍이 생깁니다. 이 책에서는 이 유형의 데이터들에게 일반적으로 다음과 같은 변수명을 부여합니다.

**<훈련 데이터>**  
X_train : 문제의 데이터  
y_train : 문제지의 대한 정답 데이터

**<테스트 데이터>**  
X_test : 시험지 데이터  
y_test : 시험지에 대한 정답 데이터  

기계는 이제부터 X_train과 y_train에 대해서 학습을 합니다. 기계는 학습 상태에서는 정답지인 y_train을 볼 수 있기 때문에 18000개의 문제지 X_train과 y_train을 함께 보면서 어떤 메일 내용일 때 정상 메일인지 스팸 메일인지를 열심히 규칙을 도출해나가면서 정리해나갑니다. 그리고 학습을 다 한 기계에게 y_test는 보여주지 않고, X_test에 대해서 정답을 예측하게 합니다. 그리고 기계가 예측한 답과 실제 정답인 y_test를 비교하면서 기계가 정답을 얼마나 맞췄는지를 평가합니다. 이 수치가 기계의 정확도(Accuary)가 됩니다.

#### 2. X와 y분리하기

##### (1) zip 함수를 이용하여 분리하기

zip()함수는 동일한 개수를 가지는 시퀀스 자료형에서 각 순서에 등장하는 원소들끼리 묶어주는 역할을 합니다. 리스트의 리스트 구성에서 zip 함수는 X와 y를 분리하는데 유용합니다. 우선 zip 함수가 어떤 역할을 하는지 확인해보도록 하겠습니다. 


```python
X, y = zip(['a', 1], ['b', 2], ['c', 3])
print('x 데이터 : ', X)
print('y 데이터 : ', y)
```

    x 데이터 :  ('a', 'b', 'c')
    y 데이터 :  (1, 2, 3)
    

각 데이터에서 첫번째로 등장한 원소들끼리 묶이고, 두번째로 등장한 원소들끼리 묶인 것을 볼 수 있습니다.


```python
# 리스트의 리스트 또는 행렬 또는 뒤에서 배울 개념인 2D 텐서.
sequnces = [['a', 1], ['b', 2], ['c', 3]]
X, y = zip(*sequnces) # *은 매개변수를 몇 개를 받을지 모를 때 유동적으로 정해준다!
print('x 데이터', X)
print('y 데이터', y)
```

    x 데이터 ('a', 'b', 'c')
    y 데이터 (1, 2, 3)
    

각 데이터에서 첫번째로 등장한 원소들끼리 묶이고, 두번째로 등장한 원소들끼리 묶인 것을 볼 수 있습니다. 이를 각각 X데이터와 y데이터로 사용할 수 있습니다.

##### (2) 데이터프레임을 이용하여 분리하기


```python
values = [['당신에게 드리는 마지막 혜택!', 1], ['내일 뵐 수 있을지 확인 부탁드...', 0], ['도연씨. 잘 지내시죠? 오랜만입...', 0], ['(광고) AI로 주가를 예측할 수 있다!', 1]]
columns = ['메일 본문', '스팸 메일 유무']

df = pd.DataFrame(values, columns = columns)

df.head(4)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>메일 본문</th>
      <th>스팸 메일 유무</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>당신에게 드리는 마지막 혜택!</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>내일 뵐 수 있을지 확인 부탁드...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>도연씨. 잘 지내시죠? 오랜만입...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>(광고) AI로 주가를 예측할 수 있다!</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



데이터프레임은 열의 이름으로 각 열에 접근이 가능하므로, 이를 이용하면 손쉽게 X 데이터와 y 데이터를 분리할 수 있습니다.


```python
X = df['메일 본문']
y = df['스팸 메일 유무']
print('x 데이터 : ', X.to_list())
print('y 데이터 : ', y.to_list())
```

    x 데이터 :  ['당신에게 드리는 마지막 혜택!', '내일 뵐 수 있을지 확인 부탁드...', '도연씨. 잘 지내시죠? 오랜만입...', '(광고) AI로 주가를 예측할 수 있다!']
    y 데이터 :  [1, 0, 0, 1]
    

##### (3) Numpy를 이용하여 분리하기

임의의 데이터를 만들어서 Numpy의 슬라이싱을 사용하여 데이터를 분리해봅시다.


```python
np_array = np.arange(0, 16).reshape((4, 4))
print('전체 데이터 : ')
print(np_array)
```

    전체 데이터 : 
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    

마지막 열을 제외하고 X데이터에 저장합니다. 마지막 열만을 y데이터에 저장합니다.


```python
X = np_array[:, :3]
y = np_array[:, 3]

print('x 데이터 : ')
print(X)
print('y 데이터 : ', y)
```

    x 데이터 : 
    [[ 0  1  2]
     [ 4  5  6]
     [ 8  9 10]
     [12 13 14]]
    y 데이터 :  [ 3  7 11 15]
    

#### 3. 테스트 데이터 분리하기

이번에는 이미 X와 y가 분리된 데이터에 대해서 테스트 데이터를 분리하는 과정에 대해서 알아보겠습니다.

##### (1) 사이킷 런을 이용하여 분리하기

사이킷런은 학습용 데이터와 테스트용 데이터를 쉽게 분리할 수 있게 해주는 train_test_split()을 지원합니다.

```python 
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 1234)
```

각 인자는 다음을 의미합니다. train_size와 test_size는 둘 중 하나만 기재해도 됩니다.

* X : 독립 변수 데이터. (배열이나 데이터프레임)
* y : 종속 변수 데이터. 레이블 데이터.
* test_size : 테스트용 데이터 개수를 지정한다. 1 보다 작은 실수를 기재할 경우, 비율을 나타낸다.
* train_size : 학습용 데이터의 개수를 지정한다. 1보다 작은 실수를 기재할 경우, 비율을 나타낸다.
* random_state : 난수 시드

예를 들어보겠습니다. 임의로 X데이터와 y데이터를 생성했습니다.


```python
# 임의로 x와 y데이터를 생성
X, y = np.arange(10).reshape((5, 2)), range(5)

print('x 전체 데이터 : ')
print(X)
print('y 전체 데이터 : ')
print(list(y))
```

    x 전체 데이터 : 
    [[0 1]
     [2 3]
     [4 5]
     [6 7]
     [8 9]]
    y 전체 데이터 : 
    [0, 1, 2, 3, 4]
    

여기서는 7:3의 비율로 데이터를 분리합니다. train_test_split()은 기본적으로 데이터의 순서를 섞고나서 훈련 데이터와 테스트 데이터를 분리합니다. 만약, random_state의 값을 특정 숫자로 기재해준 뒤에 다음에도 동일한 숫자로 기재해주면 항상 동일한 훈련 데이터와 테스트 데이터를 얻을 수 있습니다. 하지만 값을 변경하면 다른 순서로 섞인 채 분리되므로 이전과 다른 훈련 데이터와 테스트 데이터를 얻습니다. 실습을 통해서 이해해봅시다. random_state 값을 임의로 1234로 지정했습니다.


```python
# 7:3의 비율로 훈련 데이터와 테스트 데이터 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 1234)
```

70%의 비율로 분리된 X의 훈련 데이터와 30%의 비율로 분리된 X의 테스트 데이터입니다.


```python
print('x 훈련 데이터 : ')
print(X_train)
print('x 테스트 데이터 : ')
print(X_test)
```

    x 훈련 데이터 : 
    [[2 3]
     [4 5]
     [6 7]]
    x 테스트 데이터 : 
    [[8 9]
     [0 1]]
    

마찬가지로 70%의 비율로 분리된 y의 훈련 데이터와 30%의 비율로 분리된 y의 테스트 데이터입니다.


```python
print('y 훈련 데이터 : ')
print(y_train)
print('y 테스트 데이터 : ')
print(y_test)
```

    y 훈련 데이터 : 
    [1, 2, 3]
    y 테스트 데이터 : 
    [4, 0]
    

출력 결과를 보면 데이터를 어느 중간 부분에서 앞과 뒤로 자른 것이 아니라 데이터의 순서가 전반적으로 섞이면서 분리된 것을 확인할 수 있습니다. 

random_state의 값을 고정해두면 실행할 때마다 항상 동일한 순서로 데이터를 섞으므로, 동일한 코드를 다음에 재현하고자 할 때 사용할 수 있습니다.

##### (2) 수동으로 분리하기

데이터를 분리하는 방법 중 하나는 수동으로 분리하는 것입니다. 우선 임의로 X데이터와 y데이터를 만들어보겠습니다.


```python
# 실습을 위해 임의로 x와 y가 이미 분리 된 데이터를 생성
X, y = np.arange(0, 24).reshape((12, 2)), range(12)

print('x 전체 데이터 : ')
print(X)
print('y 전체 데이터 : ')
print(list(y))
```

    x 전체 데이터 : 
    [[ 0  1]
     [ 2  3]
     [ 4  5]
     [ 6  7]
     [ 8  9]
     [10 11]
     [12 13]
     [14 15]
     [16 17]
     [18 19]
     [20 21]
     [22 23]]
    y 전체 데이터 : 
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    

훈련 데이터의 개수와 테스트 데이터의 개수를 정해보겠습니다. num_of_train은 훈련 데이터의 개수를 의미하며, num_of_test는 테스트 데이터의 개수를 의미합니다.


```python
num_of_train = int(len(X) * 0.8) # 데이터의 전체 길이의 80%에 해당하는 길이 값을 구한다.
num_of_test = int(len(X) - num_of_train) # 전체 길이에서 80%에 해당하는 길이를 뺀다.

print('훈련 데이터의 크기 : ', num_of_train)
print('테스트 데이터의 크기 : ', num_of_test)
```

    훈련 데이터의 크기 :  9
    테스트 데이터의 크기 :  3
    

아직 훈련 데이터와 테스트 데이터를 나눈 것이 아니라 이 두개의 개수를 몇 개로 할지 정하기만 한 상태입니다. 여기서 num_of_test를 len(X) * 0.2로 계산해서는 안 됩니다. 데이터에 누락이 발생할 수 있습니다. 예를 들어서 전체 데이터의 개수가 4518이라고 가정했을 때 4518의 80%의 값은 3614.4로 소수점을 내리면 3614가 됩니다. 또한 4518의 20%의 값은 903.6으로 소수점을 내리면 903이 되빈다. 그리고 3614 + 903 = 4517이므로 데이터 1개가 누락이 됩니다. 그러므로 어느 한 쪽을 먼저 계산하고 그 값만큼 제외하는 방식으로 계산해야 합니다.


```python
X_test = X[num_of_train:]
y_test = y[num_of_train:]
X_train = X[:num_of_test]
y_train = y[:num_of_test]
```

데이터를 나눌 때는 num_of_train와 같이 하나의 변수만 사용하면 데이터의 누락을 방지할 수 있습니다. 앞에서 구한 데이터의 개수만큼 훈련 데이터와 테스트 데이터를 분할합니다. 그리고 테스트 데이터를 출력하여 정상적으로 분리되었는지 확인합니다.


```python
print('x 테스트 데이터 : ')
print(X_test)
print('y 테스트 데이터 : ')
print(list(y_test))
```

    x 테스트 데이터 : 
    [[18 19]
     [20 21]
     [22 23]]
    y 테스트 데이터 : 
    [9, 10, 11]
    

각 길이가 3인 것을 확인했습니다. train_test_split()과 다른 점은 데이터가 섞이지 않은 채 어느 지점에서 데이터를 앞과 뒤로 분리했다는 점입니다. 만약, 수동으로 분리하게 된다면 데이터를 분리하기 전에 수동으로 데이터를 섞는 과정이 필요할 수 있습니다. 실제로 뒤에서 이러한 실습들을 진행합니다.

### 10) 한국어 전처리 패키지(Text Preprocessing Tools for Korean Text)

유용한 한국어 전처리 패키지를 정리해봅시다. 앞서 소개한 형태소와 문장 토크나이징 도구들인 KoNLPy와 KSS(Korean Sentence Splitter)와 함께 유용하게 사용할 수 있는 패키지들입니다.

#### 1. PyKoSpacing

```python
pip install git+https://github.com/haven-jeon/PyKoSpacing.git
```

**꼭 설치할 때 cmd나 anaconda 프롬프트 창을 관리자 권한으로 열고 설치하세요!**

전희원님이 개발한 PyKoSpacing은 띄어쓰기가 되어있지 않은 문장을 띄어쓰기를 한 문장으로 변환해주는 패키지입니다. PyKoSpacing은 대용량 코퍼스를 학습하여 만들어진 띄어쓰기 딥 러닝 모델로 준수한 성능을 가지고 있습니다.


```python
sent = '김철수는 극중 두 인격의 사나이 이광수 역을 맡았다. 철수는 한국 유일의 태권도 전승자를 가리는 결전의 날을 앞두고 10년간 함께 휸련한 사형인 유연재(김광수 분)을 찾으러 속세로 내려온 인물이다.'
```

임의의 문장을 임의로 띄어쓰기가 없는 문장으로 만들었습니다.


```python
new_sent = sent.replace(" ", '') # 띄어쓰기가 없는 문장 임의로 만들기
print(new_sent)
```

    김철수는극중두인격의사나이이광수역을맡았다.철수는한국유일의태권도전승자를가리는결전의날을앞두고10년간함께휸련한사형인유연재(김광수분)을찾으러속세로내려온인물이다.
    

이를 PyKoSpacing의 입력으로 사용하여 원 문장과 비교해봅시다.


```python
from pykospacing import Spacing
spacing = Spacing()
kospacing_sent = spacing(new_sent)

print(kospacing_sent)
print(sent == kospacing_sent)
```

    김철수는 극중 두 인격의 사나이 이광수 역을 맡았다. 철수는 한국 유일의 태권도 전승자를 가리는 결전의 날을 앞두고 10년간 함께 휸련한 사형인 유연재(김광수 분)을 찾으러 속세로 내려온 인물이다.
    True
    

정확하게 결과가 일치합니다.

#### 2. Py - Hanspell

```python
pip install git+https://github.com/ssut/py-hanspell.git
```

Py-Hanspell은 네이버 한글 맞춤법 검사기를 바탕으로 만들어진 패키지입니다.


```python
from hanspell import spell_checker

sent = "맞춤법 틀리면 외 않되? 쓰고싶은대로쓰면돼지 "
spelled_sent = spell_checker.check(sent)

hanspell_sent = spelled_sent.checked
print(hanspell_sent)
```

    맞춤법 틀리면 왜 안돼? 쓰고 싶은 대로 쓰면 되지
    

이 패기지는 띄어쓰기 또한 보정합니다. PyKoSpacing에 사용한 예제를 그대로 사용해봅시다.


```python
spelled_sent = spell_checker.check(new_sent)

hanspell_sent = spelled_sent.checked
print(hanspell_sent)
print(kospacing_sent) # 앞서 사용한 kospacing 패키지에서 얻은 결과
print(hanspell_sent == kospacing_sent)
```

    김철수는 극 중 두 인격의 사나이 이광수 역을 맡았다. 철수는 한국 유일의 태권도 전승자를 가리는 결전의 날을 앞두고 10년간 함께 훈련한 사형인 유연제(김광수 분)을 찾으러 속세로 내려온 인물이다.
    김철수는 극중 두 인격의 사나이 이광수 역을 맡았다. 철수는 한국 유일의 태권도 전승자를 가리는 결전의 날을 앞두고 10년간 함께 휸련한 사형인 유연재(김광수 분)을 찾으러 속세로 내려온 인물이다.
    False
    

PyKoSpacing과 결과가 거의 비슷하지만 조금 다릅니다.

#### 3. SOYNLP를 이용한 단어 토큰화

soynlp는 품사 태깅, 단어 토큰화 등을 지원하는 단어 토크나이저입니다. 비지도학습으로 단어 토큰화를 한다는 특징을 갖고 있으며, 데이터에 자주 등장하는 단어들을 단어로 분석합니다. soynlp 단어 토크나이저는 내부적으로 단어 점수 표로 동작합니다. 이 점수는 응집 확률(cohesion probability)과 브랜칭 엔트로피(branching entropy)를 활용합니다.

```python
pip install soynlp
```

##### (1) 신조어 문제

soynlp를 소개하기 전에 기존의 형태소 분석기가 가진 문제는 무엇이었는지, SOYNLP가 어떤 점에서 유용한지 정리해봅시다. 기존의 형태소 분석기는 신조어나 형태소 분석기에 등록되지 않은 단어 같은 경우에는 제대로 구분하지 못하는 단점이 있었습니다.


```python
from konlpy.tag import Okt
tokenizer = Okt()
print(tokenizer.morphs('에이비식스 이대휘 1월 최애돌 기부 요정'))
```

    ['에이', '비식스', '이대', '휘', '1월', '최애', '돌', '기부', '요정']
    

에이비식스는 아이돌의 이름이고, 이대휘는 에이비식스 멤버이며, 최애돌은 최고로 애정하는 캐릭터라는 뜻이지만 위의 형태소 분석 결과에서는 전부 분리된 결과를 보여줍니다.

그렇다면 텍스트 데이터에서 특정 문자 시퀀스가 함께 자주 등장하는 빈도가 높고, 앞 뒤로 조사 또는 완전히 다른 단어가 등장하는 것을 고려해서 하당 문자 시퀀스를 형태소라고 판단하는 단어 토크나이저라면 어떨까요?

예를 들어 에이비식스라는 문자열이 자주 연결되어 등장한다면 한 단어라고 판단하고, 또한 에이비식스라는 단어 앞, 뒤에 '최고', '가수', '실력'과 같은 독립된 다른 단어들이 계속해서 등장한다면 에이비식스를 한 단어로 파악하는 식이지요. 그리고 이런 아이디어를 가진 단어 토크나이저가 soynlp입니다.

##### (2) 학습하기

soynlp는 기본적으로 학습에 기반한 토크나이저이므로 학습에 필요한 한국어 문서를 다운로드합니다.


```python
import urllib.request
from soynlp import DoublespaceLineCorpus
from soynlp.word import WordExtractor
```


```python
urllib.request.urlretrieve("https://raw.githubusercontent.com/lovit/soynlp/master/tutorials/2016-10-20.txt", filename = "2022-09-08.txt")
```




    ('2022-09-08.txt', <http.client.HTTPMessage at 0x2467775df70>)



훈련 데이터를 다수의 문서로 분리합니다.


```python
# 훈련 데이터를 다수의 문서로 분리
corpus = DoublespaceLineCorpus("2022-09-08.txt")
print(len(corpus))
```

    30091
    

총 30091개의 문서가 존재합니다. 상위 3개의 문서만 출력해봅시다.


```python
i = 0
for document in corpus:
    if len(document) > 0:
        print(document)
        i += 1
    if i == 3:
        break
```

    19  1990  52 1 22
    오패산터널 총격전 용의자 검거 서울 연합뉴스 경찰 관계자들이 19일 오후 서울 강북구 오패산 터널 인근에서 사제 총기를 발사해 경찰을 살해한 용의자 성모씨를 검거하고 있다 성씨는 검거 당시 서바이벌 게임에서 쓰는 방탄조끼에 헬멧까지 착용한 상태였다 독자제공 영상 캡처 연합뉴스  서울 연합뉴스 김은경 기자 사제 총기로 경찰을 살해한 범인 성모 46 씨는 주도면밀했다  경찰에 따르면 성씨는 19일 오후 강북경찰서 인근 부동산 업소 밖에서 부동산업자 이모 67 씨가 나오기를 기다렸다 이씨와는 평소에도 말다툼을 자주 한 것으로 알려졌다  이씨가 나와 걷기 시작하자 성씨는 따라가면서 미리 준비해온 사제 총기를 이씨에게 발사했다 총알이 빗나가면서 이씨는 도망갔다 그 빗나간 총알은 지나가던 행인 71 씨의 배를 스쳤다  성씨는 강북서 인근 치킨집까지 이씨 뒤를 쫓으며 실랑이하다 쓰러뜨린 후 총기와 함께 가져온 망치로 이씨 머리를 때렸다  이 과정에서 오후 6시 20분께 강북구 번동 길 위에서 사람들이 싸우고 있다 총소리가 났다 는 등의 신고가 여러건 들어왔다  5분 후에 성씨의 전자발찌가 훼손됐다는 신고가 보호관찰소 시스템을 통해 들어왔다 성범죄자로 전자발찌를 차고 있던 성씨는 부엌칼로 직접 자신의 발찌를 끊었다  용의자 소지 사제총기 2정 서울 연합뉴스 임헌정 기자 서울 시내에서 폭행 용의자가 현장 조사를 벌이던 경찰관에게 사제총기를 발사해 경찰관이 숨졌다 19일 오후 6시28분 강북구 번동에서 둔기로 맞았다 는 폭행 피해 신고가 접수돼 현장에서 조사하던 강북경찰서 번동파출소 소속 김모 54 경위가 폭행 용의자 성모 45 씨가 쏜 사제총기에 맞고 쓰러진 뒤 병원에 옮겨졌으나 숨졌다 사진은 용의자가 소지한 사제총기  신고를 받고 번동파출소에서 김창호 54 경위 등 경찰들이 오후 6시 29분께 현장으로 출동했다 성씨는 그사이 부동산 앞에 놓아뒀던 가방을 챙겨 오패산 쪽으로 도망간 후였다  김 경위는 오패산 터널 입구 오른쪽의 급경사에서 성씨에게 접근하다가 오후 6시 33분께 풀숲에 숨은 성씨가 허공에 난사한 10여발의 총알 중 일부를 왼쪽 어깨 뒷부분에 맞고 쓰러졌다  김 경위는 구급차가 도착했을 때 이미 의식이 없었고 심폐소생술을 하며 병원으로 옮겨졌으나 총알이 폐를 훼손해 오후 7시 40분께 사망했다  김 경위는 외근용 조끼를 입고 있었으나 총알을 막기에는 역부족이었다  머리에 부상을 입은 이씨도 함께 병원으로 이송됐으나 생명에는 지장이 없는 것으로 알려졌다  성씨는 오패산 터널 밑쪽 숲에서 오후 6시 45분께 잡혔다  총격현장 수색하는 경찰들 서울 연합뉴스 이효석 기자 19일 오후 서울 강북구 오패산 터널 인근에서 경찰들이 폭행 용의자가 사제총기를 발사해 경찰관이 사망한 사건을 조사 하고 있다  총 때문에 쫓던 경관들과 민간인들이 몸을 숨겼는데 인근 신발가게 직원 이모씨가 다가가 성씨를 덮쳤고 이어 현장에 있던 다른 상인들과 경찰이 가세해 체포했다  성씨는 경찰에 붙잡힌 직후 나 자살하려고 한 거다 맞아 죽어도 괜찮다 고 말한 것으로 전해졌다  성씨 자신도 경찰이 발사한 공포탄 1발 실탄 3발 중 실탄 1발을 배에 맞았으나 방탄조끼를 입은 상태여서 부상하지는 않았다  경찰은 인근을 수색해 성씨가 만든 사제총 16정과 칼 7개를 압수했다 실제 폭발할지는 알 수 없는 요구르트병에 무언가를 채워두고 심지를 꽂은 사제 폭탄도 발견됐다  일부는 숲에서 발견됐고 일부는 성씨가 소지한 가방 안에 있었다
    테헤란 연합뉴스 강훈상 특파원 이용 승객수 기준 세계 최대 공항인 아랍에미리트 두바이국제공항은 19일 현지시간 이 공항을 이륙하는 모든 항공기의 탑승객은 삼성전자의 갤럭시노트7을 휴대하면 안 된다고 밝혔다  두바이국제공항은 여러 항공 관련 기구의 권고에 따라 안전성에 우려가 있는 스마트폰 갤럭시노트7을 휴대하고 비행기를 타면 안 된다 며 탑승 전 검색 중 발견되면 압수할 계획 이라고 발표했다  공항 측은 갤럭시노트7의 배터리가 폭발 우려가 제기된 만큼 이 제품을 갖고 공항 안으로 들어오지 말라고 이용객에 당부했다  이런 조치는 두바이국제공항 뿐 아니라 신공항인 두바이월드센터에도 적용된다  배터리 폭발문제로 회수된 갤럭시노트7 연합뉴스자료사진
    

정상 출력되는 것을 확인하였습니다. soynlp는 학습 기반의 단어 토크나이저이므로 기존의 KoNLPy에서 제공하는 형태소 분석기들과는 달리 학습 과정을 거쳐야합니다. 

이는 전체 코퍼스로부터 응집 확률과 브랜칭 엔트로피 단어 점수표를 만드는 과정입니다. WordExtractor.extract()를 통해서 전체 코퍼스에 대해 단어 점수표를 계산합니다.


```python
word_extractor = WordExtractor()
word_extractor.train(corpus)
word_score_table = word_extractor.extract()
```

    training was done. used memory 0.987 Gb
    all cohesion probabilities was computed. # words = 223348
    all branching entropies was computed # words = 361598
    all accessor variety was computed # words = 361598
    

학습이 완료되었습니다.

##### (3) SOYNLP의 응집 확률(cohesion probability)

응집 확률은 내부 문자열이 얼마나 응집하여 자주 등장하는지를 판단하는 척도입니다. 응집 확률은 문자열을 문자 단위로 분리하여 내부 문자열을 만드는 과정에서 왼쪽부터 순서대로 문자를 추가하면서 각 문자열이 주어졌을 때 그 다음 문자가 나올 확률을 계산하여 누적곱을 한 값입니다. 이 값이 높을수록 전체 코퍼스에서 이 문자열 시퀀스는 하나의 단어로 등장할 가능성이 높습니다. 수식은 아래와 같습니다. 

$$
cohesion(n) = (\Pi^{n-1}_{t=1}P(c_{1:i+1}|c_{1:i}))^{\frac{1}{n-1}}
$$

'반포한강공원에'라는 7의 길이를 가진 문자 시퀀스에 대해서 각 내부 문자열의 스코어를 구하는 과정은 아래와 같습니다.

* ###### $cohesion(2) = P(반포|반)$
* ###### $cohesion(3) = \sqrt[2]{(P(반포|반) \cdot P(반포한|반포)}$
* ###### $cohesion(4) = \sqrt[3]{(P(반포|반) \cdot P(반포한|반포) \cdot P(반포한강|반포한)}$
* ###### $cohesion(5) = \sqrt[4]{(P(반포|반) \cdot P(반포한|반포) \cdot P(반포한강|반포한) \cdot P(반포한강공|반포한강)}$
* ###### $cohesion(6) = \sqrt[5]{(P(반포|반) \cdot P(반포한|반포) \cdot P(반포한강|반포한) \cdot P(반포한강공|반포한강) \cdot P(반포한강공원|반포한강공)}$
* ###### $cohesion(7) = \sqrt[6]{(P(반포|반) \cdot P(반포한|반포) \cdot P(반포한강|반포한) \cdot P(반포한강공|반포한강) \cdot P(반포한강공원|반포한강공) \cdot P(반포한강공원에|반포한강공원)}$

실습을 통해 직접 응집 확률을 계산해보겠습니다. '반포한'의 응집 확률을 계산해봅시다.

word_score_table['반포한'].cohesion_forward

그렇다면 '반포한강'의 응집 확률은 '반포한'의 응집 확률보다 높을까요?


```python
word_score_table['반포한강'].cohesion_forward
```




    0.19841268168224552



'반포한강'이 '반포한'보다 응집 확률이 더 높습니다. 그럼 이번에는 '반포한강공원에'와 '반포한강공원'을 비교해보겠습니다.


```python
print(word_score_table['반포한강공원'].cohesion_forward)
print(word_score_table['반포한강공원에'].cohesion_forward)
```

    0.37891487632839754
    0.33492963377557666
    

'반포한강공원에'보다 '반포한강공원'이 응집도가 더 높습니다. 응집도를 통해 판단하기에 하나의 단어로 판단하기에 가장 적합한 문자열은 '반포한강공원'이라고 볼 수 있겠습니다.

##### (4) SOYNLP의 브랜칭 엔트로피(branching entropy)

Branching Entropy는 확률 분포의 엔트로피값을 사용합니다. 이는 주어진 문자열에서 얼마나 다음 문자가 등잘할 수 있는지를 판단하는 척도입니다. 만약 단어가 '디스플레'까지 나왔다면 뒤에 나올 문자가 '이'로 생각해 '디스플레이'를 생각할 수 있는 것처럼 그 정도를 판단하는 척도입니다.

브랜칭 엔트로피를 주어진 문자 시퀀스에서 다음 문자 예측을 위해 헷갈리는 정도로 비유해봅시다. 브랜칭 엔트로피의 값은 하나의 완성된 단어에 가까워질수록 문맥으로 인해 점점 정확히 예측할 수 있게 되면서 점점 줄어드는 양상을 보입니다.


```python
word_score_table['디스'].right_branching_entropy
```




    1.6371694761537934




```python
word_score_table['디스플'].right_branching_entropy
```




    -0.0



'디스'다음에는 다양한 문자가 올 수 있으니까 1.63이라는 값을 가지는 반면, '디스플'이라는 문자열 다음에는 다음 문자로 '레'가 오는 것이 너무나 명백하기 때문에 0이라는 값을 가집니다.


```python
word_score_table['디스플레'].right_branching_entropy
```




    -0.0




```python
word_score_table['디스플레이'].right_branching_entropy
```




    3.1400392861792916



갑자기 값이 증가합니다. 그 이유는 문자 시퀀스 '디스플레이'라는 문자 시퀀스 다음에는 조사나 다른 단어와 같은 다양한 경우가 있을 수 있기 때문입니다. 이는 하나의 단어가 끝나면 그 경계 부분부터 다시 브랜칭 엔트로피 값이 증가하게 됨을 의미합니다. 그리고 이 값으로 단어를 판단하는 것이 가능하겠죠?

##### (5) SOYNLP의 L tokenizer

한국어는 띄어쓰기 단위로 나눈 어절 토큰은 주로 L토큰 + R토큰의 형식을 가질 때가 많습니다. 예를 들어서 '공원에'는 '공원 + 에'로 나눌 수 있겠지요. 또는 '공부하는'은 '공부 + 하는'으로 나눌 수도 있을것입니다. L토크나이저는 L토큰 + R토큰으로 나누되, 분리 기준을 점수가 가장 높은 L토큰을 찾아내는 원리를 가지고 있습니다.


```python
from soynlp.tokenizer import LTokenizer

scores = {word : score.cohesion_forward for word, score in word_score_table.items()}
l_tokenizer = LTokenizer(scores = scores)
l_tokenizer.tokenize("국제사회와 우리의 노력들로 범죄를 척결하자", flatten = False)
```




    [('국제사회', '와'), ('우리', '의'), ('노력', '들로'), ('범죄', '를'), ('척결', '하자')]



##### (6) 최대 점수 토크나이저

최대 점수 토크나이저는 띄어쓰기가 되지 않는 문장에서 점수가 높은 글자 시퀀스를 순차적으로 찾아내는 토크나이저입니다. 띄어쓰기가 되어 있지 않은 문장을 넣어서 점수를 통해 토큰화 된 결과를 보겠습니다.


```python
from soynlp.tokenizer import MaxScoreTokenizer

maxscore_tokenizer = MaxScoreTokenizer(scores = scores)
maxscore_tokenizer.tokenize("국제사회와우리의노력들로범죄를척결하자")
```




    ['국제사회', '와', '우리', '의', '노력', '들로', '범죄', '를', '척결', '하자']



#### 4. SOYNLP를 이용한 반복되는 문자 정제

SNS나 채팅 데이터와 같은 한국어 데이터의 경우에는 ㅋㅋ, ㅎㅎ 등의 이모티콘의 경우 불필요하게 연속되는 경우가 많은데, ㅋㅋ, ㅋㅋㅋ, ㅋㅋㅋㅋ와 같은 경우를 모두 서로 다른 단어로 처리하는 것은 불필요합니다. 이에 반복되는 것은 하나로 정규화시켜줍니다.


```python
from soynlp.normalizer import *
```


```python
print(emoticon_normalize('앜ㅋㅋㅋㅋ이영화존잼쓰ㅠㅠㅠㅠㅠ', num_repeats = 2))
print(emoticon_normalize('앜ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ이영화존잼쓰ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ', num_repeats = 2))
```

    아ㅋㅋ영화존잼쓰ㅠㅠ
    아ㅋㅋ영화존잼쓰ㅠㅠ
    

의미없게 반복되는 것은 비단 이모티콘에 한정되지 않습니다.


```python
print(repeat_normalize("와하하하하하하하하핫", num_repeats = 2))
```

    와하하핫
    

#### 5. Customized KoNLPy

영어권 언어는 띄어쓰기만해도 단어들이 잘 분리되지만, 한국어는 그렇지 않다고 앞에서 몇 차례 언급했었습니다. 한국어 데이터를 사용하여 모델을 구현하는 것만큼 이번에는 형태소 분석기를 사용해서 단어 토큰화를 해보겠습니다. 그런데 형태소 분석기를 사용할 때, 이런 상황에 봉착한다면 어떠헥 해야할까요?

```python
형태소 분석 입력 : '은경이는 사무실로 갔습니다.'
형태소 분석 결과 : ['은', '경이', '는', '사무실', '로', '갔습니다', '.']
```

사실 위 문장에서 '은경이'는 사람 이름이므로 제대로 된 결과를 얻기 위해서는 '은', '경이'와 같이 글자가 분리되는 것이 아니라 '은경이' 또는 최소한 '은경'이라는 단어 토큰을 얻어야만 합니다. 이런 경우에는 형태소 분석기에 사용자 사전을 추가해줄 수 있습니다. '은경이'는 하나의 단어이기 때문에 분리하지말라고 형태소 분석기에 알려주는 것입니다.

사용자 사전을 추가하는 방법은 형태소 분석기마다 다른데, 생각보다 복잡한 경우들이 많습니다. 이번 실습에서는 Customized Konlpy라는 사용자 사전 추가가 매우 쉬운 패키지를 사용합니다.

```python
pip install customized_konlpy
```

customized_konlpy에서 제공하는 형태소 분석기 Twitter를 사용하여 앞서 소개했던 예문을 단어 토큰화해봅시다.


```python
from ckonlpy.tag import Twitter

twitter = Twitter()
twitter.morphs('은경이는 사무실로 갔습니다.')
```

    C:\Users\komos\anaconda3\lib\site-packages\konlpy\tag\_okt.py:17: UserWarning: "Twitter" has changed to "Okt" since KoNLPy v0.4.5.
      warn('"Twitter" has changed to "Okt" since KoNLPy v0.4.5.')
    




    ['은', '경이', '는', '사무실', '로', '갔습니다', '.']



앞서 소개한 예시와 마찬가지로 '은경이'라는 단어가 '은', '경이'와 같이 분리됩니다. 이때, 형태소 분석기 Twitter에 add_dictionary('단어', '품사')와 같은 형식으로 사전 추가를 해줄 수 있습니다.


```python
twitter.add_dictionary('은경이', 'Noun')
```

제대로 반영되었는지 동일한 예문을 다시 형태소 분석해봅시다.


```python
twitter.morphs('은경이는 사무실로 갔습니다.')
```




    ['은경이', '는', '사무실', '로', '갔습니다', '.']



'은경이'라는 단어가 제대로 하나의 토큰으로 인식되는 것을 확인할 수 있습니다.
